// pdfExportHelpers.ts â€” PDF export utilities using jsPDF + jsPDF-AutoTable

import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { ReportData, aggregateFrameworkStats } from './exportHelpers';

// ============================================================================
// CONSTANTS
// ============================================================================

const COLORS = {
  primary: [30, 58, 95] as [number, number, number],       // #1e3a5f
  secondary: [42, 90, 138] as [number, number, number],    // #2a5a8a
  accent: [58, 106, 154] as [number, number, number],      // #3a6a9a
  text: [26, 26, 26] as [number, number, number],           // #1a1a1a
  muted: [102, 102, 102] as [number, number, number],
  success: [22, 163, 74] as [number, number, number],
  warning: [202, 138, 4] as [number, number, number],
  danger: [220, 38, 38] as [number, number, number],
  tableHeader: [30, 58, 95] as [number, number, number],
  tableAltRow: [244, 247, 251] as [number, number, number],
  criticalBg: [254, 226, 226] as [number, number, number],
  highBg: [255, 237, 213] as [number, number, number],
  moderateBg: [254, 249, 195] as [number, number, number],
  lowBg: [220, 252, 231] as [number, number, number],
  watermark: [200, 200, 200] as [number, number, number],
  footerText: [160, 174, 192] as [number, number, number],
};

const FONTS = { title: 28, h1: 18, h2: 14, h3: 12, body: 10, small: 8, meta: 9 };

const PAGE = {
  width: 215.9,
  height: 279.4,
  ml: 25.4,
  mr: 25.4,
  mt: 25.4,
  mb: 25.4,
  get cw() { return this.width - this.ml - this.mr; },
};

// ============================================================================
// INFRASTRUCTURE
// ============================================================================

function createPdfDoc(): jsPDF {
  return new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'letter' });
}

function downloadPdf(doc: jsPDF, filename: string): void {
  const safeName = filename.replace(/[^a-zA-Z0-9_\- ]/g, '').replace(/\s+/g, '_');
  doc.save(`${safeName}.pdf`);
}

function nowStr(): string {
  return new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
}

// ============================================================================
// REUSABLE BUILDING BLOCKS
// ============================================================================

function addCoverPage(doc: jsPDF, title: string, subtitle: string, orgName: string, extra?: string[]): void {
  const cx = PAGE.width / 2;
  doc.setFontSize(FONTS.title);
  doc.setTextColor(...COLORS.primary);
  doc.text(title, cx, 100, { align: 'center' });

  doc.setFontSize(18);
  doc.setTextColor(51, 51, 51);
  doc.text(subtitle, cx, 120, { align: 'center' });

  if (extra) {
    let ey = 140;
    doc.setFontSize(14);
    doc.setTextColor(85, 85, 85);
    for (const line of extra) { doc.text(line, cx, ey, { align: 'center' }); ey += 10; }
  }

  doc.setFontSize(12);
  doc.setTextColor(119, 119, 119);
  doc.text(orgName, cx, extra ? 160 : 145, { align: 'center' });

  doc.setFontSize(11);
  doc.setTextColor(153, 153, 153);
  doc.text(nowStr(), cx, extra ? 175 : 165, { align: 'center' });

  doc.setFontSize(9);
  doc.setTextColor(170, 170, 170);
  doc.text('Generated by ForgeComply 360', cx, 240, { align: 'center' });
  doc.addPage();
}

function addSectionHeading(doc: jsPDF, text: string, level: 1 | 2 | 3, y: number): number {
  y = ensureSpace(doc, y, 20);
  const sizes = { 1: FONTS.h1, 2: FONTS.h2, 3: FONTS.h3 };
  const colors = { 1: COLORS.primary, 2: COLORS.secondary, 3: COLORS.accent };
  doc.setFontSize(sizes[level]);
  doc.setTextColor(...colors[level]);
  doc.setFont('helvetica', 'bold');
  doc.text(text, PAGE.ml, y);
  if (level === 1) {
    doc.setDrawColor(...COLORS.primary);
    doc.setLineWidth(0.5);
    doc.line(PAGE.ml, y + 2, PAGE.ml + PAGE.cw, y + 2);
    return y + 10;
  }
  return y + 8;
}

function addParagraph(doc: jsPDF, text: string, y: number, opts?: { bold?: boolean; color?: [number, number, number] }): number {
  doc.setFontSize(FONTS.body);
  doc.setTextColor(...(opts?.color || COLORS.text));
  doc.setFont('helvetica', opts?.bold ? 'bold' : 'normal');
  const lines = doc.splitTextToSize(text, PAGE.cw);
  const lh = 5;
  for (const line of lines) {
    if (y > PAGE.height - PAGE.mb) { doc.addPage(); y = PAGE.mt; }
    doc.text(line, PAGE.ml, y);
    y += lh;
  }
  return y + 3;
}

function addBigMetric(doc: jsPDF, label: string, value: string, y: number, color: [number, number, number]): number {
  y = ensureSpace(doc, y, 15);
  doc.setFontSize(18);
  doc.setTextColor(...color);
  doc.setFont('helvetica', 'bold');
  doc.text(`${label}: ${value}`, PAGE.ml, y);
  doc.setFont('helvetica', 'normal');
  return y + 12;
}

function addKvTable(doc: jsPDF, rows: [string, string][], y: number): number {
  autoTable(doc, {
    startY: y,
    head: [['Attribute', 'Value']],
    body: rows,
    margin: { left: PAGE.ml, right: PAGE.mr },
    headStyles: { fillColor: COLORS.tableHeader, textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 9 },
    bodyStyles: { fontSize: 9 },
    alternateRowStyles: { fillColor: COLORS.tableAltRow },
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: 50 } },
    theme: 'grid',
  });
  return (doc as any).lastAutoTable.finalY + 8;
}

function addDataTable(
  doc: jsPDF,
  headers: string[],
  rows: (string | number)[][],
  y: number,
  opts?: { columnStyles?: Record<number, any>; didParseCell?: (data: any) => void },
): number {
  autoTable(doc, {
    startY: y,
    head: [headers],
    body: rows,
    margin: { left: PAGE.ml, right: PAGE.mr },
    headStyles: { fillColor: COLORS.tableHeader, textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 9 },
    bodyStyles: { fontSize: 8, cellPadding: 2 },
    alternateRowStyles: { fillColor: COLORS.tableAltRow },
    columnStyles: opts?.columnStyles,
    didParseCell: opts?.didParseCell,
    theme: 'grid',
  });
  return (doc as any).lastAutoTable.finalY + 8;
}

function addBulletList(doc: jsPDF, items: string[], y: number): number {
  doc.setFontSize(FONTS.body);
  doc.setTextColor(...COLORS.text);
  doc.setFont('helvetica', 'normal');
  for (const item of items) {
    y = ensureSpace(doc, y, 8);
    const lines = doc.splitTextToSize(`\u2022  ${item}`, PAGE.cw - 5);
    for (const line of lines) {
      if (y > PAGE.height - PAGE.mb) { doc.addPage(); y = PAGE.mt; }
      doc.text(line, PAGE.ml + 3, y);
      y += 5;
    }
    y += 1;
  }
  return y + 3;
}

function addPageFooter(doc: jsPDF, text: string = 'Generated by ForgeComply 360'): void {
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(7);
    doc.setTextColor(...COLORS.footerText);
    doc.text(text, PAGE.width / 2, PAGE.height - 10, { align: 'center' });
    doc.text(`Page ${i} of ${pageCount}`, PAGE.width - PAGE.mr, PAGE.height - 10, { align: 'right' });
  }
}

export function addDraftWatermark(doc: jsPDF): void {
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(60);
    doc.setTextColor(...COLORS.watermark);
    doc.setFont('helvetica', 'bold');
    doc.text('DRAFT', PAGE.width / 2, PAGE.height / 2, { align: 'center', angle: 45 });
  }
}

function ensureSpace(doc: jsPDF, y: number, needed: number): number {
  if (y + needed > PAGE.height - PAGE.mb) { doc.addPage(); return PAGE.mt; }
  return y;
}

function setDocMetadata(doc: jsPDF, title: string, orgName: string): void {
  doc.setProperties({
    title,
    subject: 'Compliance Documentation',
    author: orgName,
    creator: 'ForgeComply 360',
    keywords: 'compliance, security, GRC, ForgeComply',
  });
}

// ============================================================================
// STATUS LABEL HELPERS
// ============================================================================

const STATUS_LABELS: Record<string, string> = {
  implemented: 'Implemented',
  partially_implemented: 'Partially Implemented',
  planned: 'Planned',
  not_implemented: 'Not Implemented',
  not_applicable: 'Not Applicable',
};

const SSP_SECTION_LABELS: Record<string, string> = {
  system_info: 'System Information', authorization_boundary: 'Authorization Boundary',
  data_flow: 'Data Flow', network_architecture: 'Network Architecture',
  system_interconnections: 'System Interconnections', personnel: 'Personnel & Roles',
  control_implementations: 'Control Implementations', contingency_plan: 'Contingency Plan Summary',
  incident_response: 'Incident Response Summary', continuous_monitoring: 'Continuous Monitoring Strategy',
};

const SSP_SECTION_ORDER = [
  'system_info', 'authorization_boundary', 'data_flow', 'network_architecture',
  'system_interconnections', 'personnel', 'control_implementations',
  'contingency_plan', 'incident_response', 'continuous_monitoring',
];

// ============================================================================
// SSP EXPORTS
// ============================================================================

export async function exportFullSSPPdf(
  systemName: string,
  frameworkName: string,
  orgName: string,
  sections: Record<string, { content: string; status: string }>,
  implementations?: any[],
  isDraft?: boolean,
): Promise<void> {
  const doc = createPdfDoc();
  setDocMetadata(doc, `SSP - ${systemName} - ${frameworkName}`, orgName);

  // Cover
  addCoverPage(doc, frameworkName, 'System Security Plan', orgName, [systemName]);

  // TOC
  let y = PAGE.mt;
  y = addSectionHeading(doc, 'Table of Contents', 2, y);
  SSP_SECTION_ORDER.forEach((key, i) => {
    y = addParagraph(doc, `${i + 1}. ${SSP_SECTION_LABELS[key] || key}`, y);
  });
  if (implementations?.length) {
    y = addParagraph(doc, `${SSP_SECTION_ORDER.length + 1}. Detailed Control Implementations`, y);
  }
  doc.addPage();

  // Sections
  SSP_SECTION_ORDER.forEach((key, i) => {
    y = PAGE.mt;
    y = addSectionHeading(doc, `${i + 1}. ${SSP_SECTION_LABELS[key] || key}`, 2, y);
    const sec = sections[key];
    const text = sec?.content?.trim() || '(Section not yet completed)';
    for (const para of text.split(/\n\n+/)) {
      if (para.trim()) y = addParagraph(doc, para.trim(), y);
    }
    doc.addPage();
  });

  // Control implementations
  if (implementations?.length) {
    y = PAGE.mt;
    y = addSectionHeading(doc, `${SSP_SECTION_ORDER.length + 1}. Detailed Control Implementations`, 2, y);

    // Summary table
    const statusCounts: Record<string, number> = {};
    for (const impl of implementations) {
      const st = impl.status || 'not_implemented';
      statusCounts[st] = (statusCounts[st] || 0) + 1;
    }
    const total = implementations.length;
    const summaryRows = Object.entries(STATUS_LABELS).map(([key, label]) => {
      const count = statusCounts[key] || 0;
      const pct = total > 0 ? ((count / total) * 100).toFixed(1) + '%' : '0.0%';
      return [label, String(count), pct];
    });
    y = addDataTable(doc, ['Status', 'Count', 'Percentage'], summaryRows, y);

    // Per-control details
    for (const impl of implementations) {
      y = ensureSpace(doc, y, 35);
      const controlId = impl.control_id || impl.controlId || 'N/A';
      const title = impl.title || impl.control_title || '';
      y = addSectionHeading(doc, `${controlId}${title ? ' \u2014 ' + title : ''}`, 3, y);
      y = addKvTable(doc, [
        ['Status', STATUS_LABELS[impl.status] || impl.status || 'Not Implemented'],
        ['Responsible Role', impl.responsible_role || 'Unassigned'],
        ['Narrative', impl.narrative || impl.implementation_narrative || 'Pending'],
      ], y);
    }
  }

  if (isDraft) addDraftWatermark(doc);
  addPageFooter(doc);
  downloadPdf(doc, `SSP - ${systemName} - ${frameworkName}`);
}

export async function exportSSPSectionPdf(
  sectionLabel: string,
  sectionContent: string,
  systemName: string,
  frameworkName: string,
  orgName: string,
): Promise<void> {
  const doc = createPdfDoc();
  setDocMetadata(doc, `SSP Section - ${sectionLabel}`, orgName);

  let y = PAGE.mt;
  y = addSectionHeading(doc, `System Security Plan \u2014 ${sectionLabel}`, 1, y);
  y = addKvTable(doc, [
    ['System', systemName],
    ['Framework', frameworkName],
    ['Organization', orgName],
    ['Date', nowStr()],
  ], y);
  y = addSectionHeading(doc, sectionLabel, 2, y);
  for (const para of sectionContent.split(/\n\n+/)) {
    if (para.trim()) y = addParagraph(doc, para.trim(), y);
  }

  addPageFooter(doc);
  downloadPdf(doc, `SSP Section - ${sectionLabel} - ${systemName}`);
}

// ============================================================================
// COMPLIANCE REPORT HELPERS
// ============================================================================

function getRecommendations(data: ReportData): string[] {
  const recs: string[] = [];
  if (data.dashboard.compliance_percentage < 80) recs.push(`Increase control implementation coverage \u2014 currently at ${data.dashboard.compliance_percentage}% (target: 80%+).`);
  const crit = data.risks.by_level?.critical || 0;
  if (crit > 0) recs.push(`Address ${crit} critical risk${crit > 1 ? 's' : ''} immediately with treatment plans.`);
  const high = data.risks.by_level?.high || 0;
  if (high > 3) recs.push(`Review ${high} high-level risks and prioritize treatment.`);
  if (data.vendors.overdue_assessments > 0) recs.push(`Complete ${data.vendors.overdue_assessments} overdue vendor assessment${data.vendors.overdue_assessments > 1 ? 's' : ''}.`);
  if (data.vendors.expiring_contracts > 0) recs.push(`Review ${data.vendors.expiring_contracts} vendor contract${data.vendors.expiring_contracts > 1 ? 's' : ''} expiring within 30 days.`);
  if (data.monitoring) {
    const hp = Math.round((data.monitoring.health_score || 0) * 100);
    if (hp < 70) recs.push(`Investigate monitoring health \u2014 currently at ${hp}% (target: 70%+).`);
    if (data.monitoring.fail_count > 0) recs.push(`Remediate ${data.monitoring.fail_count} failing monitoring check${data.monitoring.fail_count > 1 ? 's' : ''}.`);
  }
  const openPoams = data.dashboard.poams.open || 0;
  if (openPoams > 5) recs.push(`Prioritize remediation of ${openPoams} open POA&M items.`);
  if (recs.length === 0) recs.push('No critical recommendations \u2014 compliance posture is strong.');
  return recs;
}

function complianceColor(pct: number): [number, number, number] {
  return pct >= 80 ? COLORS.success : pct >= 60 ? COLORS.warning : COLORS.danger;
}

// ============================================================================
// EXECUTIVE SUMMARY REPORT PDF
// ============================================================================

function renderExecutiveSummaryContent(doc: jsPDF, data: ReportData, startY?: number): number {
  const d = data.dashboard;
  const c = d.controls;
  let y = startY || PAGE.mt;

  // 1. Compliance Overview
  y = addSectionHeading(doc, '1. Compliance Overview', 2, y);
  y = addBigMetric(doc, 'Overall Compliance', `${d.compliance_percentage}%`, y, complianceColor(d.compliance_percentage));
  y = addDataTable(doc, ['Metric', 'Value'], [
    ['Total Systems', String(d.systems)],
    ['Total Controls', String(c.total)],
    ['Implemented', String(c.implemented)],
    ['Partially Implemented', String(c.partially_implemented)],
    ['Planned', String(c.planned)],
    ['Not Implemented', String(c.not_implemented)],
    ['Not Applicable', String(c.not_applicable)],
    ['Evidence Artifacts', String(d.evidence_count)],
  ], y);

  y = addSectionHeading(doc, 'POA&M Summary', 3, y);
  y = addDataTable(doc, ['Status', 'Count'], [
    ['Open', String(d.poams.open)],
    ['In Progress', String(d.poams.in_progress)],
    ['Completed', String(d.poams.completed)],
    ['Total', String(d.poams.total)],
  ], y);

  // 2. Risk Landscape
  const r = data.risks;
  y = addSectionHeading(doc, '2. Risk Landscape', 2, y);
  y = addDataTable(doc, ['Metric', 'Value'], [
    ['Total Risks', String(r.total)],
    ['Open Risks', String(r.open_count)],
    ['Average Risk Score', String(r.avg_score)],
    ['With Treatment Plans', String(r.with_treatment)],
  ], y);
  y = addSectionHeading(doc, 'Risk Distribution', 3, y);
  y = addDataTable(doc, ['Level', 'Count'], [
    ['Critical', String(r.by_level?.critical || 0)],
    ['High', String(r.by_level?.high || 0)],
    ['Moderate', String(r.by_level?.moderate || 0)],
    ['Low', String(r.by_level?.low || 0)],
  ], y, {
    didParseCell: (data: any) => {
      if (data.section === 'body' && data.column.index === 0) {
        const v = String(data.cell.raw).toLowerCase();
        if (v === 'critical') data.cell.styles.fillColor = COLORS.criticalBg;
        else if (v === 'high') data.cell.styles.fillColor = COLORS.highBg;
        else if (v === 'moderate') data.cell.styles.fillColor = COLORS.moderateBg;
        else if (v === 'low') data.cell.styles.fillColor = COLORS.lowBg;
      }
    },
  });

  // 3. Third-Party Risk
  const v = data.vendors;
  y = addSectionHeading(doc, '3. Third-Party Risk', 2, y);
  y = addDataTable(doc, ['Metric', 'Value'], [
    ['Total Vendors', String(v.total)],
    ['Critical/High Criticality', String(v.critical_high)],
    ['Average Risk Score', `${v.avg_score}/25`],
    ['Overdue Assessments', String(v.overdue_assessments)],
    ['Expiring Contracts (30d)', String(v.expiring_contracts)],
  ], y);

  if (Object.keys(v.by_criticality || {}).length > 0) {
    y = addSectionHeading(doc, 'Vendors by Criticality', 3, y);
    y = addDataTable(doc, ['Criticality', 'Count'],
      Object.entries(v.by_criticality).map(([k, val]) => [String(k).toUpperCase(), String(val)]),
    y);
  }

  // 4. Monitoring Health
  y = addSectionHeading(doc, '4. Monitoring Health', 2, y);
  if (data.monitoring) {
    const m = data.monitoring;
    const hp = Math.round((m.health_score || 0) * 100);
    y = addBigMetric(doc, 'Health Score', `${hp}%`, y, complianceColor(hp));
    y = addDataTable(doc, ['Result', 'Count'], [
      ['Pass', String(m.pass_count || 0)],
      ['Fail', String(m.fail_count || 0)],
      ['Warning', String(m.warning_count || 0)],
      ['Not Run', String(m.not_run_count || 0)],
      ['Total Checks', String(m.total_checks || 0)],
    ], y);
  } else {
    y = addParagraph(doc, 'Continuous monitoring has not been configured for this organization.', y, { color: COLORS.muted });
  }

  // 5. Key Recommendations
  y = addSectionHeading(doc, '5. Key Recommendations', 2, y);
  y = addBulletList(doc, getRecommendations(data), y);

  return y;
}

export async function exportExecutiveSummaryReportPdf(data: ReportData, orgName: string): Promise<void> {
  const doc = createPdfDoc();
  const title = 'Executive Summary Report';
  setDocMetadata(doc, title, orgName);
  addCoverPage(doc, title, 'Compliance & Risk Overview', orgName);
  renderExecutiveSummaryContent(doc, data);
  addPageFooter(doc, 'ForgeComply 360 \u2014 Reporting & Export Engine');
  downloadPdf(doc, `Executive Summary Report - ${new Date().toISOString().split('T')[0]}`);
}

// ============================================================================
// COMPLIANCE POSTURE REPORT PDF
// ============================================================================

function renderCompliancePostureContent(doc: jsPDF, data: ReportData, startY?: number): number {
  const d = data.dashboard;
  const c = d.controls;
  let y = startY || PAGE.mt;

  // 1. Overall Compliance Status
  y = addSectionHeading(doc, '1. Overall Compliance Status', 2, y);
  y = addBigMetric(doc, 'Compliance', `${d.compliance_percentage}%`, y, complianceColor(d.compliance_percentage));

  const pctOf = (n: number) => c.total > 0 ? ((n / c.total) * 100).toFixed(1) + '%' : '0.0%';
  y = addDataTable(doc, ['Status', 'Count', 'Percentage'], [
    ['Implemented', String(c.implemented), pctOf(c.implemented)],
    ['Partially Implemented', String(c.partially_implemented), pctOf(c.partially_implemented)],
    ['Planned', String(c.planned), pctOf(c.planned)],
    ['Not Implemented', String(c.not_implemented), pctOf(c.not_implemented)],
    ['Not Applicable', String(c.not_applicable), pctOf(c.not_applicable)],
    ['Total', String(c.total), '100%'],
  ], y);

  y = addSectionHeading(doc, 'POA&M Distribution', 3, y);
  y = addDataTable(doc, ['Status', 'Count'], [
    ['Open', String(d.poams.open)],
    ['In Progress', String(d.poams.in_progress)],
    ['Completed', String(d.poams.completed)],
    ['Total', String(d.poams.total)],
  ], y);

  // 2. Framework-by-Framework Breakdown
  y = addSectionHeading(doc, '2. Framework-by-Framework Breakdown', 2, y);
  const frameworks = aggregateFrameworkStats(data.frameworks);
  if (frameworks.length > 0) {
    const fwRows = frameworks.map(f => {
      const pct = f.total > 0 ? Math.round(((f.implemented + f.not_applicable) / f.total) * 100) : 0;
      return [f.name, String(f.implemented), String(f.partially_implemented), String(f.planned), String(f.not_implemented), String(f.not_applicable), String(f.total), `${pct}%`];
    });
    y = addDataTable(doc, ['Framework', 'Impl.', 'Partial', 'Planned', 'Not Impl.', 'N/A', 'Total', 'Compliance %'], fwRows, y, {
      didParseCell: (d: any) => {
        if (d.section === 'body' && d.column.index === 7) {
          const pct = parseInt(String(d.cell.raw));
          d.cell.styles.fontStyle = 'bold';
          if (pct >= 80) d.cell.styles.textColor = COLORS.success;
          else if (pct >= 60) d.cell.styles.textColor = COLORS.warning;
          else d.cell.styles.textColor = COLORS.danger;
        }
      },
    });
  } else {
    y = addParagraph(doc, 'No framework implementation data available.', y, { color: COLORS.muted });
  }

  // 3. Gap Analysis
  y = addSectionHeading(doc, '3. Gap Analysis', 2, y);
  if (data.gapAnalysis && data.gapAnalysis.length > 0) {
    y = addParagraph(doc, 'Controls with "Not Implemented" status, grouped by framework and control family:', y);
    const gapRows = data.gapAnalysis.slice(0, 30).map(g => [
      g.framework_name || g.framework_id || '', g.family || '', String(g.gap_count),
    ]);
    y = addDataTable(doc, ['Framework', 'Control Family', 'Gap Count'], gapRows, y);
  } else {
    y = addParagraph(doc, 'No implementation gaps found \u2014 all controls are implemented or planned.', y, { color: COLORS.success });
  }

  // 4. Compliance Trends
  y = addSectionHeading(doc, '4. Compliance Trends', 2, y);
  if (data.trends && data.trends.length > 0) {
    y = addParagraph(doc, 'Recent compliance snapshots (last 90 days):', y);
    const trendRows = data.trends.slice(-20).map((t: any) => [
      t.snapshot_date || '', t.system_name || '', t.framework_name || '', `${t.compliance_percentage || 0}%`,
    ]);
    y = addDataTable(doc, ['Date', 'System', 'Framework', 'Compliance %'], trendRows, y, {
      didParseCell: (d: any) => {
        if (d.section === 'body' && d.column.index === 3) {
          const pct = parseInt(String(d.cell.raw));
          d.cell.styles.fontStyle = 'bold';
          if (pct >= 80) d.cell.styles.textColor = COLORS.success;
          else if (pct >= 60) d.cell.styles.textColor = COLORS.warning;
          else d.cell.styles.textColor = COLORS.danger;
        }
      },
    });
  } else {
    y = addParagraph(doc, 'No compliance snapshots available.', y, { color: COLORS.muted });
  }

  // 5. Monitoring Health
  y = addSectionHeading(doc, '5. Monitoring Health', 2, y);
  if (data.monitoring) {
    const m = data.monitoring;
    const hp = Math.round((m.health_score || 0) * 100);
    y = addBigMetric(doc, 'Health Score', `${hp}%`, y, complianceColor(hp));
    y = addDataTable(doc, ['Result', 'Count'], [
      ['Pass', String(m.pass_count || 0)],
      ['Fail', String(m.fail_count || 0)],
      ['Warning', String(m.warning_count || 0)],
      ['Not Run', String(m.not_run_count || 0)],
    ], y);
  } else {
    y = addParagraph(doc, 'Continuous monitoring has not been configured.', y, { color: COLORS.muted });
  }

  return y;
}

export async function exportCompliancePostureReportPdf(data: ReportData, orgName: string): Promise<void> {
  const doc = createPdfDoc();
  const title = 'Compliance Posture Report';
  setDocMetadata(doc, title, orgName);
  addCoverPage(doc, title, 'Framework Analysis & Gap Assessment', orgName);
  renderCompliancePostureContent(doc, data);
  addPageFooter(doc, 'ForgeComply 360 \u2014 Reporting & Export Engine');
  downloadPdf(doc, `Compliance Posture Report - ${new Date().toISOString().split('T')[0]}`);
}

// ============================================================================
// RISK SUMMARY REPORT PDF
// ============================================================================

function renderRiskSummaryContent(doc: jsPDF, data: ReportData, startY?: number): number {
  const r = data.risks;
  let y = startY || PAGE.mt;

  // 1. Risk Overview
  y = addSectionHeading(doc, '1. Risk Overview', 2, y);
  y = addDataTable(doc, ['Metric', 'Value'], [
    ['Total Risks', String(r.total)],
    ['Open Risks', String(r.open_count)],
    ['Average Risk Score', String(r.avg_score)],
    ['With Treatment Plans', String(r.with_treatment)],
    ['Without Treatment Plans', String(r.open_count - r.with_treatment)],
  ], y);

  // 2. Risk Distribution by Level
  y = addSectionHeading(doc, '2. Risk Distribution by Level', 2, y);
  y = addDataTable(doc, ['Level', 'Count'], [
    ['Critical', String(r.by_level?.critical || 0)],
    ['High', String(r.by_level?.high || 0)],
    ['Moderate', String(r.by_level?.moderate || 0)],
    ['Low', String(r.by_level?.low || 0)],
  ], y, {
    didParseCell: (d: any) => {
      if (d.section === 'body' && d.column.index === 0) {
        const v = String(d.cell.raw).toLowerCase();
        if (v === 'critical') d.cell.styles.fillColor = COLORS.criticalBg;
        else if (v === 'high') d.cell.styles.fillColor = COLORS.highBg;
        else if (v === 'moderate') d.cell.styles.fillColor = COLORS.moderateBg;
        else if (v === 'low') d.cell.styles.fillColor = COLORS.lowBg;
      }
    },
  });

  // 3. Risk Distribution by Category
  y = addSectionHeading(doc, '3. Risk Distribution by Category', 2, y);
  const categories = Object.entries(r.by_category || {});
  if (categories.length > 0) {
    const catRows = categories.sort((a, b) => (b[1] as number) - (a[1] as number))
      .map(([cat, count]) => [String(cat).replace(/_/g, ' ').replace(/\b\w/g, ch => ch.toUpperCase()), String(count)]);
    y = addDataTable(doc, ['Category', 'Count'], catRows, y);
  } else {
    y = addParagraph(doc, 'No risk categories recorded.', y, { color: COLORS.muted });
  }

  // 4. Risk Treatment Status
  y = addSectionHeading(doc, '4. Risk Treatment Status', 2, y);
  const treatments = Object.entries(r.by_treatment || {});
  if (treatments.length > 0) {
    const tRows = treatments.sort((a, b) => (b[1] as number) - (a[1] as number))
      .map(([t, count]) => [String(t).replace(/_/g, ' ').replace(/\b\w/g, ch => ch.toUpperCase()), String(count)]);
    y = addDataTable(doc, ['Treatment', 'Count'], tRows, y);
  } else {
    y = addParagraph(doc, 'No treatment data available.', y, { color: COLORS.muted });
  }

  // 5. Vendor Risk Overview
  const v = data.vendors;
  y = addSectionHeading(doc, '5. Vendor Risk Overview', 2, y);
  y = addDataTable(doc, ['Metric', 'Value'], [
    ['Total Vendors', String(v.total)],
    ['Critical/High Criticality', String(v.critical_high)],
    ['Average Risk Score', `${v.avg_score}/25`],
    ['Overdue Assessments', String(v.overdue_assessments)],
    ['Expiring Contracts (30d)', String(v.expiring_contracts)],
  ], y);

  if (Object.keys(v.by_criticality || {}).length > 0) {
    y = addSectionHeading(doc, 'Vendors by Criticality', 3, y);
    y = addDataTable(doc, ['Criticality', 'Count'],
      Object.entries(v.by_criticality).map(([k, val]) => [String(k).toUpperCase(), String(val)]),
    y);
  }
  if (Object.keys(v.by_tier || {}).length > 0) {
    const tierLabels: Record<string, string> = { '1': 'Tier 1 (Low Risk)', '2': 'Tier 2 (Low-Moderate)', '3': 'Tier 3 (Moderate)', '4': 'Tier 4 (Critical)' };
    y = addSectionHeading(doc, 'Vendors by Risk Tier', 3, y);
    y = addDataTable(doc, ['Risk Tier', 'Count'],
      Object.entries(v.by_tier).map(([k, val]) => [tierLabels[k] || `Tier ${k}`, String(val)]),
    y);
  }

  // 6. Recommendations
  y = addSectionHeading(doc, '6. Recommendations', 2, y);
  y = addBulletList(doc, getRecommendations(data), y);

  return y;
}

export async function exportRiskSummaryReportPdf(data: ReportData, orgName: string): Promise<void> {
  const doc = createPdfDoc();
  const title = 'Risk Summary Report';
  setDocMetadata(doc, title, orgName);
  addCoverPage(doc, title, 'Enterprise Risk & Vendor Risk Overview', orgName);
  renderRiskSummaryContent(doc, data);
  addPageFooter(doc, 'ForgeComply 360 \u2014 Reporting & Export Engine');
  downloadPdf(doc, `Risk Summary Report - ${new Date().toISOString().split('T')[0]}`);
}

// ============================================================================
// AUDIT-READY PACKAGE PDF (COMBINED SINGLE FILE)
// ============================================================================

export async function exportAuditReadyPackagePdf(data: ReportData, orgName: string): Promise<void> {
  const doc = createPdfDoc();
  setDocMetadata(doc, 'Audit-Ready Compliance Package', orgName);

  // Master cover
  addCoverPage(doc, 'Audit-Ready Compliance Package', 'Executive Summary \u2022 Compliance Posture \u2022 Risk Summary', orgName);

  // Master TOC
  let y = PAGE.mt;
  y = addSectionHeading(doc, 'Package Contents', 2, y);
  y = addParagraph(doc, 'Part 1: Executive Summary Report', y, { bold: true });
  y = addParagraph(doc, 'Part 2: Compliance Posture Report', y, { bold: true });
  y = addParagraph(doc, 'Part 3: Risk Summary Report', y, { bold: true });
  doc.addPage();

  // Part 1: Executive Summary
  y = PAGE.mt;
  y = addSectionHeading(doc, 'Part 1: Executive Summary Report', 1, y);
  y += 4;
  renderExecutiveSummaryContent(doc, data, y);
  doc.addPage();

  // Part 2: Compliance Posture
  y = PAGE.mt;
  y = addSectionHeading(doc, 'Part 2: Compliance Posture Report', 1, y);
  y += 4;
  renderCompliancePostureContent(doc, data, y);
  doc.addPage();

  // Part 3: Risk Summary
  y = PAGE.mt;
  y = addSectionHeading(doc, 'Part 3: Risk Summary Report', 1, y);
  y += 4;
  renderRiskSummaryContent(doc, data, y);

  addPageFooter(doc, 'ForgeComply 360 \u2014 Audit-Ready Package');
  downloadPdf(doc, `Audit-Ready_Package_${new Date().toISOString().split('T')[0]}`);
}

// ============================================================================
// RISK REGISTER PDF
// ============================================================================

export async function exportRiskRegisterPdf(risks: any[], orgName: string): Promise<void> {
  const doc = createPdfDoc();
  setDocMetadata(doc, 'Risk Register Report', orgName);

  addCoverPage(doc, 'Risk Register Report', 'Enterprise Risk Management', orgName);

  let y = PAGE.mt;

  // Executive Summary
  const openRisks = risks.filter(r => r.status !== 'closed');
  const levelCounts: Record<string, number> = { critical: 0, high: 0, moderate: 0, low: 0 };
  for (const r of openRisks) { if (r.risk_level && levelCounts[r.risk_level] !== undefined) levelCounts[r.risk_level]++; }

  y = addSectionHeading(doc, 'Executive Summary', 2, y);
  y = addDataTable(doc, ['Metric', 'Value'], [
    ['Total Open Risks', String(openRisks.length)],
    ['Critical', String(levelCounts.critical)],
    ['High', String(levelCounts.high)],
    ['Moderate', String(levelCounts.moderate)],
    ['Low', String(levelCounts.low)],
  ], y, {
    didParseCell: (d: any) => {
      if (d.section === 'body' && d.column.index === 0) {
        const v = String(d.cell.raw).toLowerCase();
        if (v === 'critical') d.cell.styles.fillColor = COLORS.criticalBg;
        else if (v === 'high') d.cell.styles.fillColor = COLORS.highBg;
        else if (v === 'moderate') d.cell.styles.fillColor = COLORS.moderateBg;
        else if (v === 'low') d.cell.styles.fillColor = COLORS.lowBg;
      }
    },
  });

  // Full risk table
  y = addSectionHeading(doc, 'Risk Details', 2, y);
  const riskRows = risks.map(r => [
    r.risk_id || '', r.title || '', r.category || '',
    String(r.likelihood || ''), String(r.impact || ''), String(r.risk_score || ''),
    r.risk_level || '', r.treatment || '', r.owner || '', r.status || '',
  ]);
  y = addDataTable(doc, ['Risk ID', 'Title', 'Category', 'L', 'I', 'Score', 'Level', 'Treatment', 'Owner', 'Status'], riskRows, y, {
    columnStyles: { 0: { cellWidth: 18 }, 1: { cellWidth: 30 }, 3: { cellWidth: 8, halign: 'center' }, 4: { cellWidth: 8, halign: 'center' }, 5: { cellWidth: 12, halign: 'center' } },
    didParseCell: (d: any) => {
      if (d.section === 'body' && d.column.index === 6) {
        const v = String(d.cell.raw).toLowerCase();
        if (v === 'critical') d.cell.styles.fillColor = COLORS.criticalBg;
        else if (v === 'high') d.cell.styles.fillColor = COLORS.highBg;
        else if (v === 'moderate') d.cell.styles.fillColor = COLORS.moderateBg;
        else if (v === 'low') d.cell.styles.fillColor = COLORS.lowBg;
      }
    },
  });

  addPageFooter(doc, 'ForgeComply 360 \u2014 RiskForge ERM');
  downloadPdf(doc, 'Risk Register Report');
}

// ============================================================================
// COMPLIANCE DOCUMENT (ATO) PDF
// ============================================================================

export async function exportComplianceDocPdf(
  docType: string,
  title: string,
  content: string,
  metadata: Record<string, string> = {},
): Promise<void> {
  const doc = createPdfDoc();
  const systemName = metadata.systemName || metadata.system_name || 'System';
  const orgName = metadata.orgName || metadata.org_name || 'Organization';
  const impactLevel = metadata.impactLevel || metadata.impact_level || '';

  setDocMetadata(doc, title || docType, orgName);
  addCoverPage(doc, docType, systemName, orgName, impactLevel ? [`Impact Level: ${impactLevel}`] : undefined);

  let y = PAGE.mt;

  // Metadata table
  const metaEntries = Object.entries(metadata).filter(([k]) =>
    !['systemName', 'system_name', 'orgName', 'org_name', 'impactLevel', 'impact_level'].includes(k));
  if (metaEntries.length > 0 || impactLevel) {
    y = addSectionHeading(doc, 'Document Information', 2, y);
    const kvRows: [string, string][] = [
      ['System', systemName],
      ['Organization', orgName],
    ];
    if (impactLevel) kvRows.push(['Impact Level', impactLevel]);
    kvRows.push(['Date', nowStr()]);
    for (const [key, val] of metaEntries) {
      if (val) kvRows.push([key.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()), val]);
    }
    y = addKvTable(doc, kvRows, y);
  }

  // Content body
  const paragraphs = content.split(/\n\n+/);
  for (const para of paragraphs) {
    const trimmed = para.trim();
    if (!trimmed) continue;
    if (/^\d+\.\s+[A-Z]/.test(trimmed)) {
      const firstLine = trimmed.split('\n')[0];
      const rest = trimmed.slice(firstLine.length).trim();
      y = addSectionHeading(doc, firstLine, 2, y);
      if (rest) y = addParagraph(doc, rest, y);
    } else {
      y = addParagraph(doc, trimmed, y);
    }
  }

  addPageFooter(doc);
  downloadPdf(doc, title || docType);
}

const COMPLIANCE_DOC_TYPES: Record<string, string> = {
  'tpl-sar': 'Security Assessment Report (SAR)',
  'tpl-isra': 'Information System Risk Assessment (ISRA)',
  'tpl-pia': 'Privacy Impact Assessment (PIA)',
  'tpl-iscp': 'Information System Contingency Plan (ISCP)',
  'tpl-cmp': 'Configuration Management Plan (CMP)',
  'tpl-isa': 'Interconnection Security Agreement (ISA/MOU)',
  'tpl-ato-letter': 'Authorization to Operate (ATO) Letter',
  'tpl-fips199': 'FIPS 199 Security Categorization',
  'tpl-cptt': 'Contingency Plan Tabletop Exercise Report',
};

export function exportComplianceDocByTemplatePdf(
  templateId: string,
  title: string,
  content: string,
  metadata: Record<string, string> = {},
): Promise<void> {
  const docType = COMPLIANCE_DOC_TYPES[templateId] || title;
  return exportComplianceDocPdf(docType, title, content, metadata);
}
