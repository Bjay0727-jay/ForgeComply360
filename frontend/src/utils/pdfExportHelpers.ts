// pdfExportHelpers.ts — PDF export utilities using jsPDF + jsPDF-AutoTable

import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { ReportData, aggregateFrameworkStats } from './exportHelpers';

// ============================================================================
// CONSTANTS
// ============================================================================

const COLORS = {
  primary: [30, 58, 95] as [number, number, number],       // #1e3a5f
  secondary: [42, 90, 138] as [number, number, number],    // #2a5a8a
  accent: [58, 106, 154] as [number, number, number],      // #3a6a9a
  text: [26, 26, 26] as [number, number, number],           // #1a1a1a
  muted: [102, 102, 102] as [number, number, number],
  success: [22, 163, 74] as [number, number, number],
  warning: [202, 138, 4] as [number, number, number],
  danger: [220, 38, 38] as [number, number, number],
  tableHeader: [30, 58, 95] as [number, number, number],
  tableAltRow: [244, 247, 251] as [number, number, number],
  criticalBg: [254, 226, 226] as [number, number, number],
  highBg: [255, 237, 213] as [number, number, number],
  moderateBg: [254, 249, 195] as [number, number, number],
  lowBg: [220, 252, 231] as [number, number, number],
  watermark: [200, 200, 200] as [number, number, number],
  footerText: [160, 174, 192] as [number, number, number],
};

const FONTS = { title: 28, h1: 18, h2: 14, h3: 12, body: 10, small: 8, meta: 9 };

const PAGE = {
  width: 215.9,
  height: 279.4,
  ml: 25.4,
  mr: 25.4,
  mt: 25.4,
  mb: 25.4,
  get cw() { return this.width - this.ml - this.mr; },
};

// ============================================================================
// INFRASTRUCTURE
// ============================================================================

function createPdfDoc(): jsPDF {
  return new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'letter' });
}

function downloadPdf(doc: jsPDF, filename: string): void {
  const safeName = filename.replace(/[^a-zA-Z0-9_\- ]/g, '').replace(/\s+/g, '_');
  doc.save(`${safeName}.pdf`);
}

function nowStr(): string {
  return new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
}

// ============================================================================
// REUSABLE BUILDING BLOCKS
// ============================================================================

function addCoverPage(doc: jsPDF, title: string, subtitle: string, orgName: string, extra?: string[]): void {
  const cx = PAGE.width / 2;
  doc.setFontSize(FONTS.title);
  doc.setTextColor(...COLORS.primary);
  doc.text(title, cx, 100, { align: 'center' });

  doc.setFontSize(18);
  doc.setTextColor(51, 51, 51);
  doc.text(subtitle, cx, 120, { align: 'center' });

  if (extra) {
    let ey = 140;
    doc.setFontSize(14);
    doc.setTextColor(85, 85, 85);
    for (const line of extra) { doc.text(line, cx, ey, { align: 'center' }); ey += 10; }
  }

  doc.setFontSize(12);
  doc.setTextColor(119, 119, 119);
  doc.text(orgName, cx, extra ? 160 : 145, { align: 'center' });

  doc.setFontSize(11);
  doc.setTextColor(153, 153, 153);
  doc.text(nowStr(), cx, extra ? 175 : 165, { align: 'center' });

  doc.setFontSize(9);
  doc.setTextColor(170, 170, 170);
  doc.text('Generated by Forge Cyber Defense', cx, 240, { align: 'center' });
  doc.addPage();
}

/**
 * Professional cover page with CUI classification banners, organization branding, and document metadata.
 * Consistent design across all FedRAMP/ATO document types.
 */
function addProfessionalCoverPage(
  doc: jsPDF,
  docType: string,
  title: string,
  orgName: string,
  systemName?: string,
  metadata?: { version?: string; status?: string; impactLevel?: string; preparedBy?: string; date?: string },
): void {
  const cx = PAGE.width / 2;
  const classification = 'CONTROLLED UNCLASSIFIED INFORMATION (CUI)';

  // Top classification banner
  doc.setFillColor(...COLORS.danger);
  doc.rect(0, 0, PAGE.width, 12, 'F');
  doc.setFontSize(9);
  doc.setTextColor(255, 255, 255);
  doc.setFont('helvetica', 'bold');
  doc.text(classification, cx, 8, { align: 'center' });

  // Organization branding area
  doc.setFillColor(...COLORS.primary);
  doc.rect(PAGE.ml, 30, PAGE.cw, 25, 'F');
  doc.setFontSize(16);
  doc.setTextColor(255, 255, 255);
  doc.text(orgName.toUpperCase(), cx, 46, { align: 'center' });

  // Document type
  doc.setFontSize(12);
  doc.setTextColor(...COLORS.muted);
  doc.setFont('helvetica', 'normal');
  doc.text(docType.toUpperCase(), cx, 70, { align: 'center' });

  // Main title
  doc.setFontSize(24);
  doc.setTextColor(...COLORS.primary);
  doc.setFont('helvetica', 'bold');
  const titleLines = doc.splitTextToSize(title, PAGE.cw - 40);
  let ty = 90;
  for (const line of titleLines) {
    doc.text(line, cx, ty, { align: 'center' });
    ty += 10;
  }

  // System name box (if provided)
  if (systemName) {
    const boxY = ty + 10;
    doc.setFillColor(244, 247, 251);
    doc.setDrawColor(...COLORS.primary);
    doc.setLineWidth(1);
    doc.rect(PAGE.ml + 20, boxY, PAGE.cw - 40, 25, 'FD');
    doc.setFontSize(14);
    doc.setTextColor(...COLORS.primary);
    doc.setFont('helvetica', 'bold');
    doc.text(systemName, cx, boxY + 15, { align: 'center' });
    ty = boxY + 35;
  }

  // Document metadata table
  const metaY = Math.max(ty + 15, 160);
  doc.setFontSize(10);
  doc.setTextColor(...COLORS.text);

  const metaRows: [string, string][] = [
    ['Document Version:', metadata?.version || '1.0'],
    ['Document Status:', (metadata?.status || 'DRAFT').toUpperCase()],
    ['Prepared By:', metadata?.preparedBy || orgName],
    ['Date:', metadata?.date || nowStr()],
  ];

  if (metadata?.impactLevel) {
    metaRows.push(['Impact Level:', `${metadata.impactLevel.toUpperCase()} IMPACT`]);
  }

  let my = metaY;
  for (const [label, value] of metaRows) {
    doc.setFont('helvetica', 'bold');
    doc.text(label, PAGE.ml + 30, my);
    doc.setFont('helvetica', 'normal');
    doc.text(value, PAGE.ml + 80, my);
    my += 8;
  }

  // Bottom classification banner
  doc.setFillColor(...COLORS.danger);
  doc.rect(0, PAGE.height - 12, PAGE.width, 12, 'F');
  doc.setFontSize(9);
  doc.setTextColor(255, 255, 255);
  doc.setFont('helvetica', 'bold');
  doc.text(classification, cx, PAGE.height - 5, { align: 'center' });

  doc.addPage();
}

/**
 * Professional document header - appears on every page except cover
 */
function addProfessionalDocHeader(doc: jsPDF, docTitle: string, systemName: string, version: string): void {
  const pageCount = doc.getNumberOfPages();
  for (let i = 2; i <= pageCount; i++) {
    doc.setPage(i);
    // Header line
    doc.setDrawColor(...COLORS.primary);
    doc.setLineWidth(0.5);
    doc.line(PAGE.ml, 12, PAGE.width - PAGE.mr, 12);
    // Left: System/Doc name
    doc.setFontSize(8);
    doc.setTextColor(...COLORS.muted);
    doc.setFont('helvetica', 'normal');
    doc.text(systemName || docTitle, PAGE.ml, 10);
    // Center: Document title
    doc.text(docTitle, PAGE.width / 2, 10, { align: 'center' });
    // Right: Version
    doc.text(`Version ${version}`, PAGE.width - PAGE.mr, 10, { align: 'right' });
  }
}

/**
 * Professional document footer with CUI classification
 */
function addProfessionalDocFooter(doc: jsPDF, orgName: string, classification: string = 'CONTROLLED UNCLASSIFIED INFORMATION (CUI)'): void {
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    // Footer line
    doc.setDrawColor(...COLORS.primary);
    doc.setLineWidth(0.3);
    doc.line(PAGE.ml, PAGE.height - 15, PAGE.width - PAGE.mr, PAGE.height - 15);
    // Left: Classification
    doc.setFontSize(7);
    doc.setTextColor(...COLORS.danger);
    doc.setFont('helvetica', 'bold');
    doc.text(classification, PAGE.ml, PAGE.height - 11);
    // Center: Organization
    doc.setTextColor(...COLORS.muted);
    doc.setFont('helvetica', 'normal');
    doc.text(orgName, PAGE.width / 2, PAGE.height - 11, { align: 'center' });
    // Right: Page number
    doc.text(`Page ${i} of ${pageCount}`, PAGE.width - PAGE.mr, PAGE.height - 11, { align: 'right' });
    // Bottom: Generator credit
    doc.setFontSize(6);
    doc.setTextColor(...COLORS.footerText);
    doc.text('Generated by Forge Cyber Defense', PAGE.width / 2, PAGE.height - 7, { align: 'center' });
  }
}

function addSectionHeading(doc: jsPDF, text: string, level: 1 | 2 | 3, y: number): number {
  y = ensureSpace(doc, y, 20);
  const sizes = { 1: FONTS.h1, 2: FONTS.h2, 3: FONTS.h3 };
  const colors = { 1: COLORS.primary, 2: COLORS.secondary, 3: COLORS.accent };
  doc.setFontSize(sizes[level]);
  doc.setTextColor(...colors[level]);
  doc.setFont('helvetica', 'bold');
  doc.text(text, PAGE.ml, y);
  if (level === 1) {
    doc.setDrawColor(...COLORS.primary);
    doc.setLineWidth(0.5);
    doc.line(PAGE.ml, y + 2, PAGE.ml + PAGE.cw, y + 2);
    return y + 10;
  }
  return y + 8;
}

function addParagraph(doc: jsPDF, text: string, y: number, opts?: { bold?: boolean; color?: [number, number, number] }): number {
  doc.setFontSize(FONTS.body);
  doc.setTextColor(...(opts?.color || COLORS.text));
  doc.setFont('helvetica', opts?.bold ? 'bold' : 'normal');
  const lines = doc.splitTextToSize(text, PAGE.cw);
  const lh = 5;
  for (const line of lines) {
    if (y > PAGE.height - PAGE.mb) { doc.addPage(); y = PAGE.mt; }
    doc.text(line, PAGE.ml, y);
    y += lh;
  }
  return y + 3;
}

function addBigMetric(doc: jsPDF, label: string, value: string, y: number, color: [number, number, number]): number {
  y = ensureSpace(doc, y, 15);
  doc.setFontSize(18);
  doc.setTextColor(...color);
  doc.setFont('helvetica', 'bold');
  doc.text(`${label}: ${value}`, PAGE.ml, y);
  doc.setFont('helvetica', 'normal');
  return y + 12;
}

function addKvTable(doc: jsPDF, rows: [string, string][], y: number): number {
  autoTable(doc, {
    startY: y,
    head: [['Attribute', 'Value']],
    body: rows,
    margin: { left: PAGE.ml, right: PAGE.mr },
    headStyles: { fillColor: COLORS.tableHeader, textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 9 },
    bodyStyles: { fontSize: 9 },
    alternateRowStyles: { fillColor: COLORS.tableAltRow },
    columnStyles: { 0: { fontStyle: 'bold', cellWidth: 50 } },
    theme: 'grid',
  });
  return (doc as any).lastAutoTable.finalY + 8;
}

function addDataTable(
  doc: jsPDF,
  headers: string[],
  rows: (string | number)[][],
  y: number,
  opts?: { columnStyles?: Record<number, any>; didParseCell?: (data: any) => void },
): number {
  autoTable(doc, {
    startY: y,
    head: [headers],
    body: rows,
    margin: { left: PAGE.ml, right: PAGE.mr },
    headStyles: { fillColor: COLORS.tableHeader, textColor: [255, 255, 255], fontStyle: 'bold', fontSize: 9 },
    bodyStyles: { fontSize: 8, cellPadding: 2 },
    alternateRowStyles: { fillColor: COLORS.tableAltRow },
    columnStyles: opts?.columnStyles,
    didParseCell: opts?.didParseCell,
    theme: 'grid',
  });
  return (doc as any).lastAutoTable.finalY + 8;
}

function addBulletList(doc: jsPDF, items: string[], y: number): number {
  doc.setFontSize(FONTS.body);
  doc.setTextColor(...COLORS.text);
  doc.setFont('helvetica', 'normal');
  for (const item of items) {
    y = ensureSpace(doc, y, 8);
    const lines = doc.splitTextToSize(`\u2022  ${item}`, PAGE.cw - 5);
    for (const line of lines) {
      if (y > PAGE.height - PAGE.mb) { doc.addPage(); y = PAGE.mt; }
      doc.text(line, PAGE.ml + 3, y);
      y += 5;
    }
    y += 1;
  }
  return y + 3;
}

function addPageFooter(doc: jsPDF, text: string = 'Generated by Forge Cyber Defense'): void {
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(7);
    doc.setTextColor(...COLORS.footerText);
    doc.text(text, PAGE.width / 2, PAGE.height - 10, { align: 'center' });
    doc.text(`Page ${i} of ${pageCount}`, PAGE.width - PAGE.mr, PAGE.height - 10, { align: 'right' });
  }
}

export function addDraftWatermark(doc: jsPDF): void {
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(60);
    doc.setTextColor(...COLORS.watermark);
    doc.setFont('helvetica', 'bold');
    doc.text('DRAFT', PAGE.width / 2, PAGE.height / 2, { align: 'center', angle: 45 });
  }
}

function ensureSpace(doc: jsPDF, y: number, needed: number): number {
  if (y + needed > PAGE.height - PAGE.mb) { doc.addPage(); return PAGE.mt; }
  return y;
}

function setDocMetadata(doc: jsPDF, title: string, orgName: string): void {
  doc.setProperties({
    title,
    subject: 'Compliance Documentation',
    author: orgName,
    creator: 'Forge Cyber Defense',
    keywords: 'compliance, security, GRC, ForgeComply',
  });
}

// ============================================================================
// STATUS LABEL HELPERS
// ============================================================================

const STATUS_LABELS: Record<string, string> = {
  implemented: 'Implemented',
  partially_implemented: 'Partially Implemented',
  planned: 'Planned',
  not_implemented: 'Not Implemented',
  not_applicable: 'Not Applicable',
};

const SSP_SECTION_LABELS: Record<string, string> = {
  system_info: 'System Information', authorization_boundary: 'Authorization Boundary',
  data_flow: 'Data Flow', network_architecture: 'Network Architecture',
  system_interconnections: 'System Interconnections', personnel: 'Personnel & Roles',
  control_implementations: 'Control Implementations', contingency_plan: 'Contingency Plan Summary',
  incident_response: 'Incident Response Summary', continuous_monitoring: 'Continuous Monitoring Strategy',
};

const SSP_SECTION_ORDER = [
  'system_info', 'authorization_boundary', 'data_flow', 'network_architecture',
  'system_interconnections', 'personnel', 'control_implementations',
  'contingency_plan', 'incident_response', 'continuous_monitoring',
];

// ============================================================================
// SSP EXPORTS
// ============================================================================

export async function exportFullSSPPdf(
  systemName: string,
  frameworkName: string,
  orgName: string,
  sections: Record<string, { content: string; status: string }>,
  implementations?: any[],
  isDraft?: boolean,
): Promise<void> {
  const doc = createPdfDoc();
  setDocMetadata(doc, `SSP - ${systemName} - ${frameworkName}`, orgName);

  // Cover
  addCoverPage(doc, frameworkName, 'System Security Plan', orgName, [systemName]);

  // TOC
  let y = PAGE.mt;
  y = addSectionHeading(doc, 'Table of Contents', 2, y);
  SSP_SECTION_ORDER.forEach((key, i) => {
    y = addParagraph(doc, `${i + 1}. ${SSP_SECTION_LABELS[key] || key}`, y);
  });
  if (implementations?.length) {
    y = addParagraph(doc, `${SSP_SECTION_ORDER.length + 1}. Detailed Control Implementations`, y);
  }
  doc.addPage();

  // Sections
  SSP_SECTION_ORDER.forEach((key, i) => {
    y = PAGE.mt;
    y = addSectionHeading(doc, `${i + 1}. ${SSP_SECTION_LABELS[key] || key}`, 2, y);
    const sec = sections[key];
    const text = sec?.content?.trim() || '(Section not yet completed)';
    for (const para of text.split(/\n\n+/)) {
      if (para.trim()) y = addParagraph(doc, para.trim(), y);
    }
    doc.addPage();
  });

  // Control implementations
  if (implementations?.length) {
    y = PAGE.mt;
    y = addSectionHeading(doc, `${SSP_SECTION_ORDER.length + 1}. Detailed Control Implementations`, 2, y);

    // Summary table
    const statusCounts: Record<string, number> = {};
    for (const impl of implementations) {
      const st = impl.status || 'not_implemented';
      statusCounts[st] = (statusCounts[st] || 0) + 1;
    }
    const total = implementations.length;
    const summaryRows = Object.entries(STATUS_LABELS).map(([key, label]) => {
      const count = statusCounts[key] || 0;
      const pct = total > 0 ? ((count / total) * 100).toFixed(1) + '%' : '0.0%';
      return [label, String(count), pct];
    });
    y = addDataTable(doc, ['Status', 'Count', 'Percentage'], summaryRows, y);

    // Per-control details
    for (const impl of implementations) {
      y = ensureSpace(doc, y, 35);
      const controlId = impl.control_id || impl.controlId || 'N/A';
      const title = impl.title || impl.control_title || '';
      y = addSectionHeading(doc, `${controlId}${title ? ' \u2014 ' + title : ''}`, 3, y);
      y = addKvTable(doc, [
        ['Status', STATUS_LABELS[impl.status] || impl.status || 'Not Implemented'],
        ['Responsible Role', impl.responsible_role || 'Unassigned'],
        ['Narrative', impl.narrative || impl.implementation_narrative || 'Pending'],
      ], y);
    }
  }

  if (isDraft) addDraftWatermark(doc);
  addPageFooter(doc);
  downloadPdf(doc, `SSP - ${systemName} - ${frameworkName}`);
}

export async function exportSSPSectionPdf(
  sectionLabel: string,
  sectionContent: string,
  systemName: string,
  frameworkName: string,
  orgName: string,
): Promise<void> {
  const doc = createPdfDoc();
  setDocMetadata(doc, `SSP Section - ${sectionLabel}`, orgName);

  let y = PAGE.mt;
  y = addSectionHeading(doc, `System Security Plan \u2014 ${sectionLabel}`, 1, y);
  y = addKvTable(doc, [
    ['System', systemName],
    ['Framework', frameworkName],
    ['Organization', orgName],
    ['Date', nowStr()],
  ], y);
  y = addSectionHeading(doc, sectionLabel, 2, y);
  for (const para of sectionContent.split(/\n\n+/)) {
    if (para.trim()) y = addParagraph(doc, para.trim(), y);
  }

  addPageFooter(doc);
  downloadPdf(doc, `SSP Section - ${sectionLabel} - ${systemName}`);
}

// ============================================================================
// COMPLIANCE REPORT HELPERS
// ============================================================================

function getRecommendations(data: ReportData): string[] {
  const recs: string[] = [];
  if (data.dashboard.compliance_percentage < 80) recs.push(`Increase control implementation coverage \u2014 currently at ${data.dashboard.compliance_percentage}% (target: 80%+).`);
  const crit = data.risks.by_level?.critical || 0;
  if (crit > 0) recs.push(`Address ${crit} critical risk${crit > 1 ? 's' : ''} immediately with treatment plans.`);
  const high = data.risks.by_level?.high || 0;
  if (high > 3) recs.push(`Review ${high} high-level risks and prioritize treatment.`);
  if (data.vendors.overdue_assessments > 0) recs.push(`Complete ${data.vendors.overdue_assessments} overdue vendor assessment${data.vendors.overdue_assessments > 1 ? 's' : ''}.`);
  if (data.vendors.expiring_contracts > 0) recs.push(`Review ${data.vendors.expiring_contracts} vendor contract${data.vendors.expiring_contracts > 1 ? 's' : ''} expiring within 30 days.`);
  if (data.monitoring) {
    const hp = Math.round((data.monitoring.health_score || 0) * 100);
    if (hp < 70) recs.push(`Investigate monitoring health \u2014 currently at ${hp}% (target: 70%+).`);
    if (data.monitoring.fail_count > 0) recs.push(`Remediate ${data.monitoring.fail_count} failing monitoring check${data.monitoring.fail_count > 1 ? 's' : ''}.`);
  }
  const openPoams = data.dashboard.poams.open || 0;
  if (openPoams > 5) recs.push(`Prioritize remediation of ${openPoams} open POA&M items.`);
  if (recs.length === 0) recs.push('No critical recommendations \u2014 compliance posture is strong.');
  return recs;
}

function complianceColor(pct: number): [number, number, number] {
  return pct >= 80 ? COLORS.success : pct >= 60 ? COLORS.warning : COLORS.danger;
}

// ============================================================================
// EXECUTIVE SUMMARY REPORT PDF
// ============================================================================

function renderExecutiveSummaryContent(doc: jsPDF, data: ReportData, startY?: number): number {
  const d = data.dashboard;
  const c = d.controls;
  let y = startY || PAGE.mt;

  // 1. Compliance Overview
  y = addSectionHeading(doc, '1. Compliance Overview', 2, y);
  y = addBigMetric(doc, 'Overall Compliance', `${d.compliance_percentage}%`, y, complianceColor(d.compliance_percentage));
  y = addDataTable(doc, ['Metric', 'Value'], [
    ['Total Systems', String(d.systems)],
    ['Total Controls', String(c.total)],
    ['Implemented', String(c.implemented)],
    ['Partially Implemented', String(c.partially_implemented)],
    ['Planned', String(c.planned)],
    ['Not Implemented', String(c.not_implemented)],
    ['Not Applicable', String(c.not_applicable)],
    ['Evidence Artifacts', String(d.evidence_count)],
  ], y);

  y = addSectionHeading(doc, 'POA&M Summary', 3, y);
  y = addDataTable(doc, ['Status', 'Count'], [
    ['Open', String(d.poams.open)],
    ['In Progress', String(d.poams.in_progress)],
    ['Completed', String(d.poams.completed)],
    ['Total', String(d.poams.total)],
  ], y);

  // 2. Risk Landscape
  const r = data.risks;
  y = addSectionHeading(doc, '2. Risk Landscape', 2, y);
  y = addDataTable(doc, ['Metric', 'Value'], [
    ['Total Risks', String(r.total)],
    ['Open Risks', String(r.open_count)],
    ['Average Risk Score', String(r.avg_score)],
    ['With Treatment Plans', String(r.with_treatment)],
  ], y);
  y = addSectionHeading(doc, 'Risk Distribution', 3, y);
  y = addDataTable(doc, ['Level', 'Count'], [
    ['Critical', String(r.by_level?.critical || 0)],
    ['High', String(r.by_level?.high || 0)],
    ['Moderate', String(r.by_level?.moderate || 0)],
    ['Low', String(r.by_level?.low || 0)],
  ], y, {
    didParseCell: (data: any) => {
      if (data.section === 'body' && data.column.index === 0) {
        const v = String(data.cell.raw).toLowerCase();
        if (v === 'critical') data.cell.styles.fillColor = COLORS.criticalBg;
        else if (v === 'high') data.cell.styles.fillColor = COLORS.highBg;
        else if (v === 'moderate') data.cell.styles.fillColor = COLORS.moderateBg;
        else if (v === 'low') data.cell.styles.fillColor = COLORS.lowBg;
      }
    },
  });

  // 3. Third-Party Risk
  const v = data.vendors;
  y = addSectionHeading(doc, '3. Third-Party Risk', 2, y);
  y = addDataTable(doc, ['Metric', 'Value'], [
    ['Total Vendors', String(v.total)],
    ['Critical/High Criticality', String(v.critical_high)],
    ['Average Risk Score', `${v.avg_score}/25`],
    ['Overdue Assessments', String(v.overdue_assessments)],
    ['Expiring Contracts (30d)', String(v.expiring_contracts)],
  ], y);

  if (Object.keys(v.by_criticality || {}).length > 0) {
    y = addSectionHeading(doc, 'Vendors by Criticality', 3, y);
    y = addDataTable(doc, ['Criticality', 'Count'],
      Object.entries(v.by_criticality).map(([k, val]) => [String(k).toUpperCase(), String(val)]),
    y);
  }

  // 4. Monitoring Health
  y = addSectionHeading(doc, '4. Monitoring Health', 2, y);
  if (data.monitoring) {
    const m = data.monitoring;
    const hp = Math.round((m.health_score || 0) * 100);
    y = addBigMetric(doc, 'Health Score', `${hp}%`, y, complianceColor(hp));
    y = addDataTable(doc, ['Result', 'Count'], [
      ['Pass', String(m.pass_count || 0)],
      ['Fail', String(m.fail_count || 0)],
      ['Warning', String(m.warning_count || 0)],
      ['Not Run', String(m.not_run_count || 0)],
      ['Total Checks', String(m.total_checks || 0)],
    ], y);
  } else {
    y = addParagraph(doc, 'Continuous monitoring has not been configured for this organization.', y, { color: COLORS.muted });
  }

  // 5. Key Recommendations
  y = addSectionHeading(doc, '5. Key Recommendations', 2, y);
  y = addBulletList(doc, getRecommendations(data), y);

  return y;
}

export async function exportExecutiveSummaryReportPdf(data: ReportData, orgName: string, systemName?: string): Promise<void> {
  const doc = createPdfDoc();
  const title = 'Executive Summary Report';
  const docType = 'Compliance & Risk Overview';
  setDocMetadata(doc, title, orgName);

  // Professional cover page
  addProfessionalCoverPage(doc, docType, title, orgName, systemName, {
    version: '1.0',
    status: 'FINAL',
    date: nowStr(),
  });

  renderExecutiveSummaryContent(doc, data);

  // Professional headers and footers
  addProfessionalDocHeader(doc, title, systemName || orgName, '1.0');
  addProfessionalDocFooter(doc, orgName);

  downloadPdf(doc, `Executive-Summary-Report-${new Date().toISOString().split('T')[0]}`);
}

// ============================================================================
// COMPLIANCE POSTURE REPORT PDF
// ============================================================================

function renderCompliancePostureContent(doc: jsPDF, data: ReportData, startY?: number): number {
  const d = data.dashboard;
  const c = d.controls;
  let y = startY || PAGE.mt;

  // 1. Overall Compliance Status
  y = addSectionHeading(doc, '1. Overall Compliance Status', 2, y);
  y = addBigMetric(doc, 'Compliance', `${d.compliance_percentage}%`, y, complianceColor(d.compliance_percentage));

  const pctOf = (n: number) => c.total > 0 ? ((n / c.total) * 100).toFixed(1) + '%' : '0.0%';
  y = addDataTable(doc, ['Status', 'Count', 'Percentage'], [
    ['Implemented', String(c.implemented), pctOf(c.implemented)],
    ['Partially Implemented', String(c.partially_implemented), pctOf(c.partially_implemented)],
    ['Planned', String(c.planned), pctOf(c.planned)],
    ['Not Implemented', String(c.not_implemented), pctOf(c.not_implemented)],
    ['Not Applicable', String(c.not_applicable), pctOf(c.not_applicable)],
    ['Total', String(c.total), '100%'],
  ], y);

  y = addSectionHeading(doc, 'POA&M Distribution', 3, y);
  y = addDataTable(doc, ['Status', 'Count'], [
    ['Open', String(d.poams.open)],
    ['In Progress', String(d.poams.in_progress)],
    ['Completed', String(d.poams.completed)],
    ['Total', String(d.poams.total)],
  ], y);

  // 2. Framework-by-Framework Breakdown
  y = addSectionHeading(doc, '2. Framework-by-Framework Breakdown', 2, y);
  const frameworks = aggregateFrameworkStats(data.frameworks);
  if (frameworks.length > 0) {
    const fwRows = frameworks.map(f => {
      const pct = f.total > 0 ? Math.round(((f.implemented + f.not_applicable) / f.total) * 100) : 0;
      return [f.name, String(f.implemented), String(f.partially_implemented), String(f.planned), String(f.not_implemented), String(f.not_applicable), String(f.total), `${pct}%`];
    });
    y = addDataTable(doc, ['Framework', 'Impl.', 'Partial', 'Planned', 'Not Impl.', 'N/A', 'Total', 'Compliance %'], fwRows, y, {
      didParseCell: (d: any) => {
        if (d.section === 'body' && d.column.index === 7) {
          const pct = parseInt(String(d.cell.raw));
          d.cell.styles.fontStyle = 'bold';
          if (pct >= 80) d.cell.styles.textColor = COLORS.success;
          else if (pct >= 60) d.cell.styles.textColor = COLORS.warning;
          else d.cell.styles.textColor = COLORS.danger;
        }
      },
    });
  } else {
    y = addParagraph(doc, 'No framework implementation data available.', y, { color: COLORS.muted });
  }

  // 3. Gap Analysis
  y = addSectionHeading(doc, '3. Gap Analysis', 2, y);
  if (data.gapAnalysis && data.gapAnalysis.length > 0) {
    y = addParagraph(doc, 'Controls with "Not Implemented" status, grouped by framework and control family:', y);
    const gapRows = data.gapAnalysis.slice(0, 30).map(g => [
      g.framework_name || g.framework_id || '', g.family || '', String(g.gap_count),
    ]);
    y = addDataTable(doc, ['Framework', 'Control Family', 'Gap Count'], gapRows, y);
  } else {
    y = addParagraph(doc, 'No implementation gaps found \u2014 all controls are implemented or planned.', y, { color: COLORS.success });
  }

  // 4. Compliance Trends
  y = addSectionHeading(doc, '4. Compliance Trends', 2, y);
  if (data.trends && data.trends.length > 0) {
    y = addParagraph(doc, 'Recent compliance snapshots (last 90 days):', y);
    const trendRows = data.trends.slice(-20).map((t: any) => [
      t.snapshot_date || '', t.system_name || '', t.framework_name || '', `${t.compliance_percentage || 0}%`,
    ]);
    y = addDataTable(doc, ['Date', 'System', 'Framework', 'Compliance %'], trendRows, y, {
      didParseCell: (d: any) => {
        if (d.section === 'body' && d.column.index === 3) {
          const pct = parseInt(String(d.cell.raw));
          d.cell.styles.fontStyle = 'bold';
          if (pct >= 80) d.cell.styles.textColor = COLORS.success;
          else if (pct >= 60) d.cell.styles.textColor = COLORS.warning;
          else d.cell.styles.textColor = COLORS.danger;
        }
      },
    });
  } else {
    y = addParagraph(doc, 'No compliance snapshots available.', y, { color: COLORS.muted });
  }

  // 5. Monitoring Health
  y = addSectionHeading(doc, '5. Monitoring Health', 2, y);
  if (data.monitoring) {
    const m = data.monitoring;
    const hp = Math.round((m.health_score || 0) * 100);
    y = addBigMetric(doc, 'Health Score', `${hp}%`, y, complianceColor(hp));
    y = addDataTable(doc, ['Result', 'Count'], [
      ['Pass', String(m.pass_count || 0)],
      ['Fail', String(m.fail_count || 0)],
      ['Warning', String(m.warning_count || 0)],
      ['Not Run', String(m.not_run_count || 0)],
    ], y);
  } else {
    y = addParagraph(doc, 'Continuous monitoring has not been configured.', y, { color: COLORS.muted });
  }

  return y;
}

export async function exportCompliancePostureReportPdf(data: ReportData, orgName: string, systemName?: string): Promise<void> {
  const doc = createPdfDoc();
  const title = 'Compliance Posture Report';
  const docType = 'Framework Analysis & Gap Assessment';
  setDocMetadata(doc, title, orgName);

  // Professional cover page
  addProfessionalCoverPage(doc, docType, title, orgName, systemName, {
    version: '1.0',
    status: 'FINAL',
    date: nowStr(),
  });

  renderCompliancePostureContent(doc, data);

  // Professional headers and footers
  addProfessionalDocHeader(doc, title, systemName || orgName, '1.0');
  addProfessionalDocFooter(doc, orgName);

  downloadPdf(doc, `Compliance-Posture-Report-${new Date().toISOString().split('T')[0]}`);
}

// ============================================================================
// RISK SUMMARY REPORT PDF
// ============================================================================

function renderRiskSummaryContent(doc: jsPDF, data: ReportData, startY?: number): number {
  const r = data.risks;
  let y = startY || PAGE.mt;

  // 1. Risk Overview
  y = addSectionHeading(doc, '1. Risk Overview', 2, y);
  y = addDataTable(doc, ['Metric', 'Value'], [
    ['Total Risks', String(r.total)],
    ['Open Risks', String(r.open_count)],
    ['Average Risk Score', String(r.avg_score)],
    ['With Treatment Plans', String(r.with_treatment)],
    ['Without Treatment Plans', String(r.open_count - r.with_treatment)],
  ], y);

  // 2. Risk Distribution by Level
  y = addSectionHeading(doc, '2. Risk Distribution by Level', 2, y);
  y = addDataTable(doc, ['Level', 'Count'], [
    ['Critical', String(r.by_level?.critical || 0)],
    ['High', String(r.by_level?.high || 0)],
    ['Moderate', String(r.by_level?.moderate || 0)],
    ['Low', String(r.by_level?.low || 0)],
  ], y, {
    didParseCell: (d: any) => {
      if (d.section === 'body' && d.column.index === 0) {
        const v = String(d.cell.raw).toLowerCase();
        if (v === 'critical') d.cell.styles.fillColor = COLORS.criticalBg;
        else if (v === 'high') d.cell.styles.fillColor = COLORS.highBg;
        else if (v === 'moderate') d.cell.styles.fillColor = COLORS.moderateBg;
        else if (v === 'low') d.cell.styles.fillColor = COLORS.lowBg;
      }
    },
  });

  // 3. Risk Distribution by Category
  y = addSectionHeading(doc, '3. Risk Distribution by Category', 2, y);
  const categories = Object.entries(r.by_category || {});
  if (categories.length > 0) {
    const catRows = categories.sort((a, b) => (b[1] as number) - (a[1] as number))
      .map(([cat, count]) => [String(cat).replace(/_/g, ' ').replace(/\b\w/g, ch => ch.toUpperCase()), String(count)]);
    y = addDataTable(doc, ['Category', 'Count'], catRows, y);
  } else {
    y = addParagraph(doc, 'No risk categories recorded.', y, { color: COLORS.muted });
  }

  // 4. Risk Treatment Status
  y = addSectionHeading(doc, '4. Risk Treatment Status', 2, y);
  const treatments = Object.entries(r.by_treatment || {});
  if (treatments.length > 0) {
    const tRows = treatments.sort((a, b) => (b[1] as number) - (a[1] as number))
      .map(([t, count]) => [String(t).replace(/_/g, ' ').replace(/\b\w/g, ch => ch.toUpperCase()), String(count)]);
    y = addDataTable(doc, ['Treatment', 'Count'], tRows, y);
  } else {
    y = addParagraph(doc, 'No treatment data available.', y, { color: COLORS.muted });
  }

  // 5. Vendor Risk Overview
  const v = data.vendors;
  y = addSectionHeading(doc, '5. Vendor Risk Overview', 2, y);
  y = addDataTable(doc, ['Metric', 'Value'], [
    ['Total Vendors', String(v.total)],
    ['Critical/High Criticality', String(v.critical_high)],
    ['Average Risk Score', `${v.avg_score}/25`],
    ['Overdue Assessments', String(v.overdue_assessments)],
    ['Expiring Contracts (30d)', String(v.expiring_contracts)],
  ], y);

  if (Object.keys(v.by_criticality || {}).length > 0) {
    y = addSectionHeading(doc, 'Vendors by Criticality', 3, y);
    y = addDataTable(doc, ['Criticality', 'Count'],
      Object.entries(v.by_criticality).map(([k, val]) => [String(k).toUpperCase(), String(val)]),
    y);
  }
  if (Object.keys(v.by_tier || {}).length > 0) {
    const tierLabels: Record<string, string> = { '1': 'Tier 1 (Low Risk)', '2': 'Tier 2 (Low-Moderate)', '3': 'Tier 3 (Moderate)', '4': 'Tier 4 (Critical)' };
    y = addSectionHeading(doc, 'Vendors by Risk Tier', 3, y);
    y = addDataTable(doc, ['Risk Tier', 'Count'],
      Object.entries(v.by_tier).map(([k, val]) => [tierLabels[k] || `Tier ${k}`, String(val)]),
    y);
  }

  // 6. Recommendations
  y = addSectionHeading(doc, '6. Recommendations', 2, y);
  y = addBulletList(doc, getRecommendations(data), y);

  return y;
}

export async function exportRiskSummaryReportPdf(data: ReportData, orgName: string, systemName?: string): Promise<void> {
  const doc = createPdfDoc();
  const title = 'Risk Summary Report';
  const docType = 'Enterprise Risk & Vendor Risk Overview';
  setDocMetadata(doc, title, orgName);

  // Professional cover page
  addProfessionalCoverPage(doc, docType, title, orgName, systemName, {
    version: '1.0',
    status: 'FINAL',
    date: nowStr(),
  });

  renderRiskSummaryContent(doc, data);

  // Professional headers and footers
  addProfessionalDocHeader(doc, title, systemName || orgName, '1.0');
  addProfessionalDocFooter(doc, orgName);

  downloadPdf(doc, `Risk-Summary-Report-${new Date().toISOString().split('T')[0]}`);
}

// ============================================================================
// AUDIT-READY PACKAGE PDF (COMBINED SINGLE FILE)
// ============================================================================

export async function exportAuditReadyPackagePdf(data: ReportData, orgName: string, systemName?: string): Promise<void> {
  const doc = createPdfDoc();
  const title = 'Audit-Ready Compliance Package';
  const docType = 'Comprehensive Compliance Documentation';
  setDocMetadata(doc, title, orgName);

  // Professional cover page
  addProfessionalCoverPage(doc, docType, title, orgName, systemName, {
    version: '1.0',
    status: 'FINAL',
    date: nowStr(),
  });

  // Master TOC
  let y = PAGE.mt;
  doc.setFontSize(FONTS.h1);
  doc.setTextColor(...COLORS.primary);
  doc.setFont('helvetica', 'bold');
  doc.text('TABLE OF CONTENTS', PAGE.ml, y);
  doc.setDrawColor(...COLORS.primary);
  doc.setLineWidth(0.5);
  doc.line(PAGE.ml, y + 3, PAGE.ml + 60, y + 3);
  y += 15;

  const tocItems = [
    'Part 1: Executive Summary Report',
    'Part 2: Compliance Posture Report',
    'Part 3: Risk Summary Report',
  ];

  doc.setFontSize(11);
  for (const item of tocItems) {
    doc.setTextColor(...COLORS.text);
    doc.setFont('helvetica', 'normal');
    doc.text(item, PAGE.ml + 5, y);
    y += 8;
  }
  doc.addPage();

  // Part 1: Executive Summary
  y = PAGE.mt;
  y = addSectionHeading(doc, 'Part 1: Executive Summary Report', 1, y);
  y += 4;
  renderExecutiveSummaryContent(doc, data, y);
  doc.addPage();

  // Part 2: Compliance Posture
  y = PAGE.mt;
  y = addSectionHeading(doc, 'Part 2: Compliance Posture Report', 1, y);
  y += 4;
  renderCompliancePostureContent(doc, data, y);
  doc.addPage();

  // Part 3: Risk Summary
  y = PAGE.mt;
  y = addSectionHeading(doc, 'Part 3: Risk Summary Report', 1, y);
  y += 4;
  renderRiskSummaryContent(doc, data, y);

  // Professional headers and footers
  addProfessionalDocHeader(doc, title, systemName || orgName, '1.0');
  addProfessionalDocFooter(doc, orgName);

  downloadPdf(doc, `Audit-Ready-Package-${new Date().toISOString().split('T')[0]}`);
}

// ============================================================================
// RISK REGISTER PDF - Professional Format
// ============================================================================

export async function exportRiskRegisterPdf(risks: any[], orgName: string, systemName?: string): Promise<void> {
  const doc = createPdfDoc();
  const title = 'Risk Register Report';
  const docType = 'Enterprise Risk Management';
  setDocMetadata(doc, title, orgName);

  // Professional cover page
  addProfessionalCoverPage(doc, docType, title, orgName, systemName, {
    version: '1.0',
    status: 'FINAL',
    date: nowStr(),
  });

  let y = PAGE.mt;

  // Executive Summary
  const openRisks = risks.filter(r => r.status !== 'closed');
  const levelCounts: Record<string, number> = { critical: 0, high: 0, moderate: 0, low: 0 };
  for (const r of openRisks) { if (r.risk_level && levelCounts[r.risk_level] !== undefined) levelCounts[r.risk_level]++; }

  y = addSectionHeading(doc, '1. Executive Summary', 1, y);
  y = addParagraph(doc, `This Risk Register documents ${risks.length} identified risks for ${systemName || orgName}. Of these, ${openRisks.length} risks are currently open and require ongoing management.`, y);
  y += 3;

  y = addSectionHeading(doc, 'Risk Distribution by Level', 2, y);
  y = addDataTable(doc, ['Risk Level', 'Count', 'Percentage'], [
    ['Critical', String(levelCounts.critical), `${risks.length > 0 ? ((levelCounts.critical / openRisks.length) * 100).toFixed(1) : 0}%`],
    ['High', String(levelCounts.high), `${risks.length > 0 ? ((levelCounts.high / openRisks.length) * 100).toFixed(1) : 0}%`],
    ['Moderate', String(levelCounts.moderate), `${risks.length > 0 ? ((levelCounts.moderate / openRisks.length) * 100).toFixed(1) : 0}%`],
    ['Low', String(levelCounts.low), `${risks.length > 0 ? ((levelCounts.low / openRisks.length) * 100).toFixed(1) : 0}%`],
    ['Total Open', String(openRisks.length), '100%'],
  ], y, {
    didParseCell: (d: any) => {
      if (d.section === 'body' && d.column.index === 0) {
        const v = String(d.cell.raw).toLowerCase();
        if (v === 'critical') d.cell.styles.fillColor = COLORS.criticalBg;
        else if (v === 'high') d.cell.styles.fillColor = COLORS.highBg;
        else if (v === 'moderate') d.cell.styles.fillColor = COLORS.moderateBg;
        else if (v === 'low') d.cell.styles.fillColor = COLORS.lowBg;
      }
    },
  });

  // Full risk table
  doc.addPage();
  y = PAGE.mt;
  y = addSectionHeading(doc, '2. Risk Details', 1, y);
  const riskRows = risks.map(r => [
    r.risk_id || '', r.title || '', r.category || '',
    String(r.likelihood || ''), String(r.impact || ''), String(r.risk_score || ''),
    r.risk_level || '', r.treatment || '', r.owner || '', r.status || '',
  ]);
  y = addDataTable(doc, ['Risk ID', 'Title', 'Category', 'L', 'I', 'Score', 'Level', 'Treatment', 'Owner', 'Status'], riskRows, y, {
    columnStyles: { 0: { cellWidth: 18 }, 1: { cellWidth: 30 }, 3: { cellWidth: 8, halign: 'center' }, 4: { cellWidth: 8, halign: 'center' }, 5: { cellWidth: 12, halign: 'center' } },
    didParseCell: (d: any) => {
      if (d.section === 'body' && d.column.index === 6) {
        const v = String(d.cell.raw).toLowerCase();
        if (v === 'critical') d.cell.styles.fillColor = COLORS.criticalBg;
        else if (v === 'high') d.cell.styles.fillColor = COLORS.highBg;
        else if (v === 'moderate') d.cell.styles.fillColor = COLORS.moderateBg;
        else if (v === 'low') d.cell.styles.fillColor = COLORS.lowBg;
      }
    },
  });

  // Professional headers and footers
  addProfessionalDocHeader(doc, title, systemName || orgName, '1.0');
  addProfessionalDocFooter(doc, orgName);

  downloadPdf(doc, `Risk-Register-${new Date().toISOString().split('T')[0]}`);
}

// ============================================================================
// COMPLIANCE DOCUMENT (ATO) PDF - Professional Format
// ============================================================================

export async function exportComplianceDocPdf(
  docType: string,
  title: string,
  content: string,
  metadata: Record<string, string> = {},
): Promise<void> {
  const doc = createPdfDoc();
  const systemName = metadata.systemName || metadata.system_name || 'System';
  const orgName = metadata.orgName || metadata.org_name || 'Organization';
  const impactLevel = metadata.impactLevel || metadata.impact_level || '';
  const version = metadata.version || '1.0';
  const status = metadata.status || 'draft';

  setDocMetadata(doc, title || docType, orgName);

  // Professional cover page
  addProfessionalCoverPage(doc, docType, title || docType, orgName, systemName, {
    version,
    status,
    impactLevel: impactLevel || undefined,
    preparedBy: metadata.preparedBy || metadata.prepared_by,
    date: metadata.date || nowStr(),
  });

  let y = PAGE.mt + 5;

  // Table of Contents (for longer documents)
  const sections = extractSectionsFromContent(content);
  if (sections.length > 3) {
    y = addSectionHeading(doc, 'Table of Contents', 1, y);
    for (let i = 0; i < sections.length; i++) {
      doc.setFontSize(10);
      doc.setTextColor(...COLORS.text);
      doc.setFont('helvetica', 'normal');
      const tocText = `${i + 1}. ${sections[i].title}`;
      doc.text(tocText, PAGE.ml + 5, y);
      y += 6;
      if (y > PAGE.height - PAGE.mb - 20) { doc.addPage(); y = PAGE.mt; }
    }
    doc.addPage();
    y = PAGE.mt;
  }

  // Document Information section
  y = addSectionHeading(doc, 'Document Information', 1, y);
  const kvRows: [string, string][] = [
    ['Document Type', docType],
    ['System', systemName],
    ['Organization', orgName],
  ];
  if (impactLevel) kvRows.push(['Security Categorization', `${impactLevel.toUpperCase()} IMPACT`]);
  kvRows.push(['Document Version', version]);
  kvRows.push(['Status', status.replace('_', ' ').toUpperCase()]);
  kvRows.push(['Date', nowStr()]);

  // Add additional metadata
  const metaEntries = Object.entries(metadata).filter(([k]) =>
    !['systemName', 'system_name', 'orgName', 'org_name', 'impactLevel', 'impact_level', 'version', 'status', 'preparedBy', 'prepared_by', 'date'].includes(k));
  for (const [key, val] of metaEntries) {
    if (val) kvRows.push([key.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase()), val]);
  }
  y = addKvTable(doc, kvRows, y);
  y += 5;

  // Content body with smart section parsing
  const paragraphs = content.split(/\n\n+/);
  let currentSectionNum = 0;

  for (const para of paragraphs) {
    const trimmed = para.trim();
    if (!trimmed) continue;

    // Detect numbered section headers
    const sectionMatch = trimmed.match(/^(\d+)\.\s+(.+)/);
    if (sectionMatch) {
      const lines = trimmed.split('\n');
      const headerLine = lines[0];
      const restContent = lines.slice(1).join('\n').trim();

      // Check if this is a main section (start new page for major sections)
      if (currentSectionNum > 0 && parseInt(sectionMatch[1]) !== currentSectionNum) {
        doc.addPage();
        y = PAGE.mt;
      }
      currentSectionNum = parseInt(sectionMatch[1]);

      y = addSectionHeading(doc, headerLine, 1, y);
      if (restContent) {
        y = addParagraph(doc, restContent, y);
      }
    } else if (/^[A-Z][A-Za-z\s]+:$/.test(trimmed.split('\n')[0])) {
      // Subsection header (e.g., "Purpose:", "Scope:")
      const lines = trimmed.split('\n');
      y = addSectionHeading(doc, lines[0].replace(':', ''), 2, y);
      if (lines.length > 1) {
        y = addParagraph(doc, lines.slice(1).join('\n').trim(), y);
      }
    } else if (trimmed.startsWith('•') || trimmed.startsWith('-') || trimmed.startsWith('*')) {
      // Bullet list
      const items = trimmed.split('\n').map(line => line.replace(/^[•\-*]\s*/, '').trim()).filter(Boolean);
      y = addBulletList(doc, items, y);
    } else {
      // Regular paragraph
      y = addParagraph(doc, trimmed, y);
    }

    // Page break if needed
    if (y > PAGE.height - PAGE.mb - 10) {
      doc.addPage();
      y = PAGE.mt;
    }
  }

  // Add professional headers and footers
  addProfessionalDocHeader(doc, docType, systemName, version);
  addProfessionalDocFooter(doc, orgName);

  // Add draft watermark if status is draft
  if (status.toLowerCase() === 'draft' || status.toLowerCase() === 'in_review') {
    addDraftWatermark(doc);
  }

  downloadPdf(doc, `${docType.replace(/\s+/g, '-')}-${systemName.replace(/\s+/g, '-')}-${nowStr().replace(/,?\s+/g, '-')}`);
}

/**
 * Extract section titles from content for TOC generation
 */
function extractSectionsFromContent(content: string): { title: string; level: number }[] {
  const sections: { title: string; level: number }[] = [];
  const lines = content.split('\n');

  for (const line of lines) {
    const trimmed = line.trim();
    const match = trimmed.match(/^(\d+)\.\s+(.+)/);
    if (match) {
      sections.push({ title: match[2], level: 1 });
    }
  }

  return sections;
}

const COMPLIANCE_DOC_TYPES: Record<string, string> = {
  'tpl-sar': 'Security Assessment Report (SAR)',
  'tpl-isra': 'Information System Risk Assessment (ISRA)',
  'tpl-pia': 'Privacy Impact Assessment (PIA)',
  'tpl-iscp': 'Information System Contingency Plan (ISCP)',
  'tpl-cmp': 'Configuration Management Plan (CMP)',
  'tpl-isa': 'Interconnection Security Agreement (ISA/MOU)',
  'tpl-ato-letter': 'Authorization to Operate (ATO) Letter',
  'tpl-fips199': 'FIPS 199 Security Categorization',
  'tpl-cptt': 'Contingency Plan Tabletop Exercise Report',
};

export function exportComplianceDocByTemplatePdf(
  templateId: string,
  title: string,
  content: string,
  metadata: Record<string, string> = {},
): Promise<void> {
  const docType = COMPLIANCE_DOC_TYPES[templateId] || title;
  return exportComplianceDocPdf(docType, title, content, metadata);
}

// ============================================================================
// PROFESSIONAL SSP EXPORT (FedRAMP-Compliant Format)
// ============================================================================

export interface SSPExportData {
  systemName: string;
  systemAcronym?: string;
  frameworkName: string;
  orgName: string;
  version?: string;
  status?: 'draft' | 'in_review' | 'approved' | 'published';
  preparedBy?: string;
  preparedDate?: string;
  // FIPS 199 Categorization
  fips199?: {
    confidentiality: 'Low' | 'Moderate' | 'High';
    integrity: 'Low' | 'Moderate' | 'High';
    availability: 'Low' | 'Moderate' | 'High';
    overallLevel: 'Low' | 'Moderate' | 'High';
    justification?: string;
  };
  // Roles
  roles?: {
    authorizingOfficial?: { name: string; title: string; org: string };
    systemOwner?: { name: string; title: string; org: string };
    isso?: { name: string; title: string; org: string };
    securityEngineer?: { name: string; title: string; org: string };
    assessor?: { name: string; title: string; org: string };
  };
  // Environment
  environment?: {
    cloudProvider?: string;
    deploymentModel?: string;
    serviceModel?: string;
    securityServices?: string[];
    diagramPlaceholder?: boolean;
  };
  // Sections content
  sections: Record<string, { content: string; status: string }>;
  // Control implementations
  implementations?: any[];
  // Control baseline info
  controlBaseline?: {
    name: string;
    revision: string;
    totalControls: number;
    inheritedControls?: number;
    systemImplemented?: number;
  };
}

const PROFESSIONAL_SSP_SECTIONS = [
  { key: 'executive_summary', label: 'Executive Summary', number: '1' },
  { key: 'system_description', label: 'System Description and Boundary', number: '2' },
  { key: 'fips199_categorization', label: 'FIPS 199 Security Categorization', number: '3' },
  { key: 'control_baseline', label: 'Control Baseline', number: '4' },
  { key: 'control_implementations', label: 'Control Implementation Summary', number: '5' },
  { key: 'roles_responsibilities', label: 'Roles and Responsibilities', number: '6' },
  { key: 'environment_architecture', label: 'Environment and Architecture', number: '7' },
  { key: 'authorization_boundary', label: 'Authorization Boundary', number: '8' },
  { key: 'data_flow', label: 'Data Flow', number: '9' },
  { key: 'network_architecture', label: 'Network Architecture', number: '10' },
  { key: 'system_interconnections', label: 'System Interconnections', number: '11' },
  { key: 'contingency_plan', label: 'Contingency Plan Summary', number: '12' },
  { key: 'incident_response', label: 'Incident Response Summary', number: '13' },
  { key: 'continuous_monitoring', label: 'Continuous Monitoring Strategy', number: '14' },
  { key: 'control_details', label: 'Detailed Control Implementations', number: 'Appendix A' },
];

function addProfessionalHeader(doc: jsPDF, systemName: string, docTitle: string, version: string): void {
  const pageCount = doc.getNumberOfPages();
  for (let i = 2; i <= pageCount; i++) { // Skip cover page
    doc.setPage(i);
    // Header line
    doc.setDrawColor(...COLORS.primary);
    doc.setLineWidth(0.5);
    doc.line(PAGE.ml, 12, PAGE.width - PAGE.mr, 12);
    // Left: System name
    doc.setFontSize(8);
    doc.setTextColor(...COLORS.muted);
    doc.setFont('helvetica', 'normal');
    doc.text(systemName, PAGE.ml, 10);
    // Center: Document title
    doc.text(docTitle, PAGE.width / 2, 10, { align: 'center' });
    // Right: Version
    doc.text(`Version ${version}`, PAGE.width - PAGE.mr, 10, { align: 'right' });
  }
}

function addProfessionalFooter(doc: jsPDF, orgName: string, classification: string = 'CONTROLLED UNCLASSIFIED INFORMATION (CUI)'): void {
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    // Footer line
    doc.setDrawColor(...COLORS.primary);
    doc.setLineWidth(0.3);
    doc.line(PAGE.ml, PAGE.height - 15, PAGE.width - PAGE.mr, PAGE.height - 15);
    // Left: Classification
    doc.setFontSize(7);
    doc.setTextColor(...COLORS.danger);
    doc.setFont('helvetica', 'bold');
    doc.text(classification, PAGE.ml, PAGE.height - 11);
    // Center: Organization
    doc.setTextColor(...COLORS.muted);
    doc.setFont('helvetica', 'normal');
    doc.text(orgName, PAGE.width / 2, PAGE.height - 11, { align: 'center' });
    // Right: Page number
    doc.text(`Page ${i} of ${pageCount}`, PAGE.width - PAGE.mr, PAGE.height - 11, { align: 'right' });
    // Bottom: Generator credit
    doc.setFontSize(6);
    doc.setTextColor(...COLORS.footerText);
    doc.text('Generated by Forge Cyber Defense', PAGE.width / 2, PAGE.height - 7, { align: 'center' });
  }
}

function addProfessionalCover(doc: jsPDF, data: SSPExportData): void {
  const cx = PAGE.width / 2;

  // Top classification banner
  doc.setFillColor(...COLORS.danger);
  doc.rect(0, 0, PAGE.width, 12, 'F');
  doc.setFontSize(9);
  doc.setTextColor(255, 255, 255);
  doc.setFont('helvetica', 'bold');
  doc.text('CONTROLLED UNCLASSIFIED INFORMATION (CUI)', cx, 8, { align: 'center' });

  // Logo placeholder area
  doc.setFillColor(...COLORS.primary);
  doc.rect(PAGE.ml, 30, PAGE.cw, 25, 'F');
  doc.setFontSize(16);
  doc.setTextColor(255, 255, 255);
  doc.text(data.orgName.toUpperCase(), cx, 46, { align: 'center' });

  // Main title
  doc.setFontSize(28);
  doc.setTextColor(...COLORS.primary);
  doc.setFont('helvetica', 'bold');
  doc.text('SYSTEM SECURITY PLAN', cx, 85, { align: 'center' });

  // Framework
  doc.setFontSize(16);
  doc.setTextColor(...COLORS.secondary);
  doc.text(data.frameworkName, cx, 100, { align: 'center' });

  // System name box
  doc.setFillColor(244, 247, 251);
  doc.setDrawColor(...COLORS.primary);
  doc.setLineWidth(1);
  doc.rect(PAGE.ml + 20, 115, PAGE.cw - 40, 30, 'FD');
  doc.setFontSize(18);
  doc.setTextColor(...COLORS.primary);
  doc.setFont('helvetica', 'bold');
  doc.text(data.systemName, cx, 130, { align: 'center' });
  if (data.systemAcronym) {
    doc.setFontSize(12);
    doc.setFont('helvetica', 'normal');
    doc.text(`(${data.systemAcronym})`, cx, 140, { align: 'center' });
  }

  // Document metadata table
  const metaY = 160;
  doc.setFontSize(10);
  doc.setTextColor(...COLORS.text);

  const metaRows: [string, string][] = [
    ['Document Version:', data.version || '1.0'],
    ['Document Status:', (data.status || 'draft').replace('_', ' ').toUpperCase()],
    ['Prepared By:', data.preparedBy || data.orgName],
    ['Prepared Date:', data.preparedDate || nowStr()],
  ];

  if (data.fips199?.overallLevel) {
    metaRows.push(['Security Categorization:', `${data.fips199.overallLevel.toUpperCase()} IMPACT`]);
  }

  let my = metaY;
  for (const [label, value] of metaRows) {
    doc.setFont('helvetica', 'bold');
    doc.text(label, PAGE.ml + 30, my);
    doc.setFont('helvetica', 'normal');
    doc.text(value, PAGE.ml + 80, my);
    my += 8;
  }

  // Bottom classification banner
  doc.setFillColor(...COLORS.danger);
  doc.rect(0, PAGE.height - 12, PAGE.width, 12, 'F');
  doc.setFontSize(9);
  doc.setTextColor(255, 255, 255);
  doc.setFont('helvetica', 'bold');
  doc.text('CONTROLLED UNCLASSIFIED INFORMATION (CUI)', cx, PAGE.height - 5, { align: 'center' });

  doc.addPage();
}

function addTableOfContents(doc: jsPDF, hasImplementations: boolean): void {
  let y = PAGE.mt + 5;

  doc.setFontSize(FONTS.h1);
  doc.setTextColor(...COLORS.primary);
  doc.setFont('helvetica', 'bold');
  doc.text('TABLE OF CONTENTS', PAGE.ml, y);
  doc.setDrawColor(...COLORS.primary);
  doc.setLineWidth(0.5);
  doc.line(PAGE.ml, y + 3, PAGE.ml + 60, y + 3);
  y += 15;

  doc.setFontSize(11);
  doc.setFont('helvetica', 'normal');

  for (const section of PROFESSIONAL_SSP_SECTIONS) {
    if (section.key === 'control_details' && !hasImplementations) continue;

    doc.setTextColor(...COLORS.text);
    const text = `${section.number}. ${section.label}`;
    doc.text(text, PAGE.ml + 5, y);

    // Dot leader
    const textWidth = doc.getTextWidth(text);
    doc.setTextColor(...COLORS.muted);
    const dotsStart = PAGE.ml + 10 + textWidth;
    const dotsEnd = PAGE.width - PAGE.mr - 15;
    let dx = dotsStart;
    while (dx < dotsEnd) {
      doc.text('.', dx, y);
      dx += 2;
    }
    y += 8;
  }

  doc.addPage();
}

function addFIPS199Section(doc: jsPDF, data: SSPExportData, sectionNum: string): number {
  let y = PAGE.mt;
  y = addSectionHeading(doc, `${sectionNum}. FIPS 199 Security Categorization`, 1, y);

  if (!data.fips199) {
    y = addParagraph(doc, 'Security categorization has not been completed for this system. A FIPS 199 Security Categorization document should be developed to determine the appropriate impact levels for confidentiality, integrity, and availability.', y);
    return y;
  }

  y = addParagraph(doc, `In accordance with FIPS Publication 199 (Standards for Security Categorization of Federal Information and Information Systems) and NIST SP 800-60, the security categorization for ${data.systemName} has been determined as follows:`, y);
  y += 5;

  // CIA Table
  y = addDataTable(doc, ['Security Objective', 'Impact Level', 'Justification'], [
    ['Confidentiality', data.fips199.confidentiality, 'Based on information type analysis per NIST SP 800-60'],
    ['Integrity', data.fips199.integrity, 'Based on information type analysis per NIST SP 800-60'],
    ['Availability', data.fips199.availability, 'Based on information type analysis per NIST SP 800-60'],
  ], y, {
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: 40 },
      1: { cellWidth: 30, halign: 'center' },
      2: { cellWidth: 'auto' },
    },
  });

  // Overall categorization box
  y += 5;
  doc.setFillColor(244, 247, 251);
  doc.setDrawColor(...COLORS.primary);
  doc.setLineWidth(0.5);
  doc.rect(PAGE.ml, y, PAGE.cw, 25, 'FD');

  doc.setFontSize(10);
  doc.setTextColor(...COLORS.muted);
  doc.setFont('helvetica', 'normal');
  doc.text('Overall System Security Categorization (High Water Mark):', PAGE.ml + 5, y + 8);

  doc.setFontSize(14);
  doc.setTextColor(...COLORS.primary);
  doc.setFont('helvetica', 'bold');
  doc.text(`SC ${data.systemAcronym || data.systemName} = {(C, ${data.fips199.confidentiality}), (I, ${data.fips199.integrity}), (A, ${data.fips199.availability})} = ${data.fips199.overallLevel.toUpperCase()} IMPACT`, PAGE.ml + 5, y + 18);

  y += 35;

  if (data.fips199.justification) {
    y = addSectionHeading(doc, 'Categorization Justification', 3, y);
    y = addParagraph(doc, data.fips199.justification, y);
  }

  return y;
}

function addControlBaselineSection(doc: jsPDF, data: SSPExportData, sectionNum: string): number {
  let y = PAGE.mt;
  y = addSectionHeading(doc, `${sectionNum}. Control Baseline`, 1, y);

  const baseline = data.controlBaseline || {
    name: data.frameworkName,
    revision: 'Rev 5',
    totalControls: data.implementations?.length || 0,
  };

  y = addParagraph(doc, `The security control baseline for ${data.systemName} is derived from the following authoritative source:`, y);
  y += 3;

  y = addKvTable(doc, [
    ['Control Framework', baseline.name],
    ['Revision', baseline.revision],
    ['Impact Level', data.fips199?.overallLevel || 'Moderate'],
    ['Total Baseline Controls', String(baseline.totalControls)],
  ], y);

  y = addSectionHeading(doc, 'Control Responsibility', 3, y);
  y = addParagraph(doc, 'Controls within this SSP are categorized by implementation responsibility:', y);

  const inheritedCount = baseline.inheritedControls || Math.round(baseline.totalControls * 0.3);
  const systemCount = baseline.systemImplemented || (baseline.totalControls - inheritedCount);

  y = addDataTable(doc, ['Category', 'Count', 'Description'], [
    ['Inherited Controls', String(inheritedCount), 'Controls fully satisfied by the cloud service provider (CSP)'],
    ['System-Implemented', String(systemCount), 'Controls implemented at the application or customer responsibility layer'],
    ['Shared Controls', String(Math.round(baseline.totalControls * 0.15)), 'Controls with shared responsibility between CSP and customer'],
  ], y);

  return y;
}

function addRolesSection(doc: jsPDF, data: SSPExportData, sectionNum: string): number {
  let y = PAGE.mt;
  y = addSectionHeading(doc, `${sectionNum}. Roles and Responsibilities`, 1, y);

  y = addParagraph(doc, 'The following individuals and organizational roles are responsible for the security of this information system:', y);
  y += 5;

  const roles = data.roles || {};

  const roleData: [string, string, string, string][] = [
    ['Authorizing Official (AO)', roles.authorizingOfficial?.name || 'TBD', roles.authorizingOfficial?.title || 'TBD', 'Accepts risk and authorizes system operation'],
    ['System Owner', roles.systemOwner?.name || 'TBD', roles.systemOwner?.title || 'TBD', 'Responsible for overall system operation and security'],
    ['Information System Security Officer (ISSO)', roles.isso?.name || 'TBD', roles.isso?.title || 'TBD', 'Day-to-day security operations and monitoring'],
    ['Security Engineer', roles.securityEngineer?.name || 'TBD', roles.securityEngineer?.title || 'TBD', 'Implements and maintains security controls'],
    ['Third Party Assessor (3PAO)', roles.assessor?.name || 'TBD', roles.assessor?.title || 'TBD', 'Independent security assessment'],
  ];

  y = addDataTable(doc, ['Role', 'Name', 'Title', 'Responsibility'], roleData, y, {
    columnStyles: {
      0: { fontStyle: 'bold', cellWidth: 45 },
      1: { cellWidth: 35 },
      2: { cellWidth: 35 },
      3: { cellWidth: 'auto' },
    },
  });

  return y;
}

function addEnvironmentSection(doc: jsPDF, data: SSPExportData, sectionNum: string): number {
  let y = PAGE.mt;
  y = addSectionHeading(doc, `${sectionNum}. Environment and Architecture`, 1, y);

  const env = data.environment || {};

  y = addParagraph(doc, `${data.systemName} operates in a cloud-native environment with the following characteristics:`, y);
  y += 3;

  y = addKvTable(doc, [
    ['Cloud Provider', env.cloudProvider || 'AWS GovCloud (US)'],
    ['Deployment Model', env.deploymentModel || 'Government Community Cloud'],
    ['Service Model', env.serviceModel || 'Platform as a Service (PaaS)'],
  ], y);

  if (env.securityServices?.length) {
    y = addSectionHeading(doc, 'Security Services', 3, y);
    y = addBulletList(doc, env.securityServices, y);
  } else {
    y = addSectionHeading(doc, 'Security Services', 3, y);
    y = addBulletList(doc, [
      'AWS Identity and Access Management (IAM)',
      'AWS Key Management Service (KMS)',
      'AWS CloudTrail for audit logging',
      'AWS GuardDuty for threat detection',
      'AWS Config for configuration monitoring',
      'AWS WAF for web application firewall',
    ], y);
  }

  y += 5;

  // Architecture diagram placeholder
  doc.setFillColor(248, 250, 252);
  doc.setDrawColor(...COLORS.muted);
  doc.setLineWidth(0.3);
  doc.setLineDashPattern([2, 2], 0);
  doc.rect(PAGE.ml, y, PAGE.cw, 50, 'FD');
  doc.setLineDashPattern([], 0);

  doc.setFontSize(11);
  doc.setTextColor(...COLORS.muted);
  doc.setFont('helvetica', 'italic');
  doc.text('[Architecture Diagram Placeholder]', PAGE.width / 2, y + 20, { align: 'center' });
  doc.setFontSize(9);
  doc.text('Insert system architecture diagram showing security boundaries,', PAGE.width / 2, y + 30, { align: 'center' });
  doc.text('data flows, and key security components.', PAGE.width / 2, y + 37, { align: 'center' });

  y += 60;

  return y;
}

export async function exportProfessionalSSPPdf(data: SSPExportData): Promise<void> {
  const doc = createPdfDoc();
  const docTitle = `System Security Plan - ${data.systemAcronym || data.systemName}`;
  setDocMetadata(doc, docTitle, data.orgName);

  // Cover page
  addProfessionalCover(doc, data);

  // Table of Contents
  addTableOfContents(doc, !!(data.implementations?.length));

  // Section 1: Executive Summary
  let y = PAGE.mt;
  y = addSectionHeading(doc, '1. Executive Summary', 1, y);
  const execContent = data.sections.executive_summary?.content || data.sections.system_info?.content;
  if (execContent?.trim()) {
    for (const para of execContent.split(/\n\n+/)) {
      if (para.trim()) y = addParagraph(doc, para.trim(), y);
    }
  } else {
    y = addParagraph(doc, `This System Security Plan (SSP) documents the security controls implemented for ${data.systemName} in accordance with ${data.frameworkName}. The system has been categorized as ${data.fips199?.overallLevel || 'Moderate'} impact based on FIPS 199 analysis.`, y);
  }
  doc.addPage();

  // Section 2: System Description
  y = PAGE.mt;
  y = addSectionHeading(doc, '2. System Description and Boundary', 1, y);
  const sysDesc = data.sections.system_description?.content || data.sections.system_info?.content;
  if (sysDesc?.trim()) {
    for (const para of sysDesc.split(/\n\n+/)) {
      if (para.trim()) y = addParagraph(doc, para.trim(), y);
    }
  } else {
    y = addParagraph(doc, '(System description content to be completed)', y);
  }
  doc.addPage();

  // Section 3: FIPS 199 Categorization
  addFIPS199Section(doc, data, '3');
  doc.addPage();

  // Section 4: Control Baseline
  addControlBaselineSection(doc, data, '4');
  doc.addPage();

  // Section 5: Control Implementation Summary
  y = PAGE.mt;
  y = addSectionHeading(doc, '5. Control Implementation Summary', 1, y);

  if (data.implementations?.length) {
    y = addParagraph(doc, 'The following table summarizes the implementation status of security controls:', y);

    const statusCounts: Record<string, number> = {};
    for (const impl of data.implementations) {
      const st = impl.status || 'not_implemented';
      statusCounts[st] = (statusCounts[st] || 0) + 1;
    }
    const total = data.implementations.length;

    const summaryRows = Object.entries(STATUS_LABELS).map(([key, label]) => {
      const count = statusCounts[key] || 0;
      const pct = total > 0 ? ((count / total) * 100).toFixed(1) + '%' : '0.0%';
      return [label, String(count), pct];
    });

    y = addDataTable(doc, ['Implementation Status', 'Count', 'Percentage'], summaryRows, y);

    // Sample implementation (first implemented control)
    const sampleImpl = data.implementations.find(i => i.status === 'implemented' && i.narrative);
    if (sampleImpl) {
      y = addSectionHeading(doc, 'Sample Control Implementation', 3, y);
      y = addKvTable(doc, [
        ['Control ID', sampleImpl.control_id || sampleImpl.controlId],
        ['Title', sampleImpl.title || sampleImpl.control_title || 'N/A'],
        ['Status', STATUS_LABELS[sampleImpl.status] || sampleImpl.status],
        ['Implementation', sampleImpl.narrative || sampleImpl.implementation_narrative || 'N/A'],
      ], y);
    }
  } else {
    y = addParagraph(doc, 'Control implementation details are managed within the Forge Cyber Defense platform. Each control includes implementation narrative, responsible party, and evidence linkage.', y);
  }
  doc.addPage();

  // Section 6: Roles and Responsibilities
  addRolesSection(doc, data, '6');
  doc.addPage();

  // Section 7: Environment and Architecture
  addEnvironmentSection(doc, data, '7');
  doc.addPage();

  // Sections 8-14: Remaining SSP sections
  const remainingSections = [
    { num: '8', key: 'authorization_boundary', label: 'Authorization Boundary' },
    { num: '9', key: 'data_flow', label: 'Data Flow' },
    { num: '10', key: 'network_architecture', label: 'Network Architecture' },
    { num: '11', key: 'system_interconnections', label: 'System Interconnections' },
    { num: '12', key: 'contingency_plan', label: 'Contingency Plan Summary' },
    { num: '13', key: 'incident_response', label: 'Incident Response Summary' },
    { num: '14', key: 'continuous_monitoring', label: 'Continuous Monitoring Strategy' },
  ];

  for (const section of remainingSections) {
    y = PAGE.mt;
    y = addSectionHeading(doc, `${section.num}. ${section.label}`, 1, y);
    const content = data.sections[section.key]?.content;
    if (content?.trim()) {
      for (const para of content.split(/\n\n+/)) {
        if (para.trim()) y = addParagraph(doc, para.trim(), y);
      }
    } else {
      y = addParagraph(doc, '(Section content to be completed)', y);
    }
    doc.addPage();
  }

  // Appendix A: Detailed Control Implementations
  if (data.implementations?.length) {
    y = PAGE.mt;
    y = addSectionHeading(doc, 'Appendix A. Detailed Control Implementations', 1, y);

    for (const impl of data.implementations) {
      y = ensureSpace(doc, y, 40);
      const controlId = impl.control_id || impl.controlId || 'N/A';
      const title = impl.title || impl.control_title || '';
      y = addSectionHeading(doc, `${controlId}${title ? ' — ' + title : ''}`, 3, y);
      y = addKvTable(doc, [
        ['Status', STATUS_LABELS[impl.status] || impl.status || 'Not Implemented'],
        ['Responsible Role', impl.responsible_role || 'Unassigned'],
        ['Implementation Narrative', impl.narrative || impl.implementation_narrative || 'Pending'],
      ], y);
    }
  }

  // Add watermark if draft
  if (data.status === 'draft' || data.status === 'in_review') {
    addDraftWatermark(doc);
  }

  // Add professional headers and footers
  addProfessionalHeader(doc, data.systemAcronym || data.systemName, 'System Security Plan', data.version || '1.0');
  addProfessionalFooter(doc, data.orgName);

  downloadPdf(doc, `SSP-${data.systemAcronym || data.systemName}-${data.frameworkName.replace(/\s+/g, '-')}`);
}
